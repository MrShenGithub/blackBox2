// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol_message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocol_5fmessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protocol_5fmessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protocol_5fmessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protocol_5fmessage_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_5fmessage_2eproto;
namespace asf {
namespace msgbus {
namespace blackbox2 {
namespace protocol {
class AttachResponse;
struct AttachResponseDefaultTypeInternal;
extern AttachResponseDefaultTypeInternal _AttachResponse_default_instance_;
class Boolean;
struct BooleanDefaultTypeInternal;
extern BooleanDefaultTypeInternal _Boolean_default_instance_;
class Channel;
struct ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class Channel_ConfigEntry_DoNotUse;
struct Channel_ConfigEntry_DoNotUseDefaultTypeInternal;
extern Channel_ConfigEntry_DoNotUseDefaultTypeInternal _Channel_ConfigEntry_DoNotUse_default_instance_;
class Executor;
struct ExecutorDefaultTypeInternal;
extern ExecutorDefaultTypeInternal _Executor_default_instance_;
class ExecutorTask;
struct ExecutorTaskDefaultTypeInternal;
extern ExecutorTaskDefaultTypeInternal _ExecutorTask_default_instance_;
class Handle;
struct HandleDefaultTypeInternal;
extern HandleDefaultTypeInternal _Handle_default_instance_;
class Handle_MappingChannelsEntry_DoNotUse;
struct Handle_MappingChannelsEntry_DoNotUseDefaultTypeInternal;
extern Handle_MappingChannelsEntry_DoNotUseDefaultTypeInternal _Handle_MappingChannelsEntry_DoNotUse_default_instance_;
class Instance;
struct InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class KeyStat;
struct KeyStatDefaultTypeInternal;
extern KeyStatDefaultTypeInternal _KeyStat_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class MessageFields;
struct MessageFieldsDefaultTypeInternal;
extern MessageFieldsDefaultTypeInternal _MessageFields_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Process;
struct ProcessDefaultTypeInternal;
extern ProcessDefaultTypeInternal _Process_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class String;
struct StringDefaultTypeInternal;
extern StringDefaultTypeInternal _String_default_instance_;
class Thread;
struct ThreadDefaultTypeInternal;
extern ThreadDefaultTypeInternal _Thread_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace protocol
}  // namespace blackbox2
}  // namespace msgbus
}  // namespace asf
PROTOBUF_NAMESPACE_OPEN
template<> ::asf::msgbus::blackbox2::protocol::AttachResponse* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::AttachResponse>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Boolean* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Boolean>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Channel* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Channel>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Channel_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Channel_ConfigEntry_DoNotUse>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Executor* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Executor>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::ExecutorTask* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::ExecutorTask>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Handle* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Handle>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Handle_MappingChannelsEntry_DoNotUse* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Handle_MappingChannelsEntry_DoNotUse>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Instance* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Instance>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::KeyStat* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::KeyStat>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Message* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Message>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::MessageFields* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::MessageFields>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Node* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Node>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Process* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Process>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Result* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Result>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::String* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::String>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Thread* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Thread>(Arena*);
template<> ::asf::msgbus::blackbox2::protocol::Version* Arena::CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace asf {
namespace msgbus {
namespace blackbox2 {
namespace protocol {

enum Direction : int {
  In = 0,
  Out = 1,
  Both = 2,
  Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Direction_IsValid(int value);
constexpr Direction Direction_MIN = In;
constexpr Direction Direction_MAX = Both;
constexpr int Direction_ARRAYSIZE = Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Direction_descriptor();
template<typename T>
inline const std::string& Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Direction_descriptor(), enum_t_value);
}
inline bool Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Direction>(
    Direction_descriptor(), name, value);
}
enum HandleType : int {
  Reader = 0,
  Writer = 1,
  Client = 2,
  Server = 3,
  Unknown = 4,
  HandleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HandleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HandleType_IsValid(int value);
constexpr HandleType HandleType_MIN = Reader;
constexpr HandleType HandleType_MAX = Unknown;
constexpr int HandleType_ARRAYSIZE = HandleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HandleType_descriptor();
template<typename T>
inline const std::string& HandleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HandleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HandleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HandleType_descriptor(), enum_t_value);
}
inline bool HandleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HandleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HandleType>(
    HandleType_descriptor(), name, value);
}
// ===================================================================

class Boolean final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.Boolean) */ {
 public:
  inline Boolean() : Boolean(nullptr) {}
  ~Boolean() override;
  explicit constexpr Boolean(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Boolean(const Boolean& from);
  Boolean(Boolean&& from) noexcept
    : Boolean() {
    *this = ::std::move(from);
  }

  inline Boolean& operator=(const Boolean& from) {
    CopyFrom(from);
    return *this;
  }
  inline Boolean& operator=(Boolean&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Boolean& default_instance() {
    return *internal_default_instance();
  }
  static inline const Boolean* internal_default_instance() {
    return reinterpret_cast<const Boolean*>(
               &_Boolean_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Boolean& a, Boolean& b) {
    a.Swap(&b);
  }
  inline void Swap(Boolean* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Boolean* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Boolean* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Boolean>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Boolean& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Boolean& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Boolean* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.Boolean";
  }
  protected:
  explicit Boolean(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.Boolean)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class String final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.String) */ {
 public:
  inline String() : String(nullptr) {}
  ~String() override;
  explicit constexpr String(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  String(const String& from);
  String(String&& from) noexcept
    : String() {
    *this = ::std::move(from);
  }

  inline String& operator=(const String& from) {
    CopyFrom(from);
    return *this;
  }
  inline String& operator=(String&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const String& default_instance() {
    return *internal_default_instance();
  }
  static inline const String* internal_default_instance() {
    return reinterpret_cast<const String*>(
               &_String_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(String& a, String& b) {
    a.Swap(&b);
  }
  inline void Swap(String* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(String* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  String* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<String>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const String& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const String& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(String* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.String";
  }
  protected:
  explicit String(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.String)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Instance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.Instance) */ {
 public:
  inline Instance() : Instance(nullptr) {}
  ~Instance() override;
  explicit constexpr Instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Instance(const Instance& from);
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instance& operator=(Instance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Instance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }
  inline void Swap(Instance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Instance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Instance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Instance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.Instance";
  }
  protected:
  explicit Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.Instance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() override;
  explicit constexpr Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.Result";
  }
  protected:
  explicit Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // uint32 code = 1;
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Version final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() override;
  explicit constexpr Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Version& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMajorNumberFieldNumber = 1,
    kMinorNumberFieldNumber = 2,
    kPatchNumberFieldNumber = 3,
  };
  // uint32 major_number = 1;
  void clear_major_number();
  uint32_t major_number() const;
  void set_major_number(uint32_t value);
  private:
  uint32_t _internal_major_number() const;
  void _internal_set_major_number(uint32_t value);
  public:

  // uint32 minor_number = 2;
  void clear_minor_number();
  uint32_t minor_number() const;
  void set_minor_number(uint32_t value);
  private:
  uint32_t _internal_minor_number() const;
  void _internal_set_minor_number(uint32_t value);
  public:

  // uint32 patch_number = 3;
  void clear_patch_number();
  uint32_t patch_number() const;
  void set_patch_number(uint32_t value);
  private:
  uint32_t _internal_patch_number() const;
  void _internal_set_patch_number(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t major_number_;
  uint32_t minor_number_;
  uint32_t patch_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Thread final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.Thread) */ {
 public:
  inline Thread() : Thread(nullptr) {}
  ~Thread() override;
  explicit constexpr Thread(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Thread(const Thread& from);
  Thread(Thread&& from) noexcept
    : Thread() {
    *this = ::std::move(from);
  }

  inline Thread& operator=(const Thread& from) {
    CopyFrom(from);
    return *this;
  }
  inline Thread& operator=(Thread&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Thread& default_instance() {
    return *internal_default_instance();
  }
  static inline const Thread* internal_default_instance() {
    return reinterpret_cast<const Thread*>(
               &_Thread_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Thread& a, Thread& b) {
    a.Swap(&b);
  }
  inline void Swap(Thread* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Thread* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Thread* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Thread>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Thread& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Thread& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Thread* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.Thread";
  }
  protected:
  explicit Thread(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.Thread)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Process final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.Process) */ {
 public:
  inline Process() : Process(nullptr) {}
  ~Process() override;
  explicit constexpr Process(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Process(const Process& from);
  Process(Process&& from) noexcept
    : Process() {
    *this = ::std::move(from);
  }

  inline Process& operator=(const Process& from) {
    CopyFrom(from);
    return *this;
  }
  inline Process& operator=(Process&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Process& default_instance() {
    return *internal_default_instance();
  }
  static inline const Process* internal_default_instance() {
    return reinterpret_cast<const Process*>(
               &_Process_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Process& a, Process& b) {
    a.Swap(&b);
  }
  inline void Swap(Process* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Process* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Process* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Process>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Process& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Process& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Process* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.Process";
  }
  protected:
  explicit Process(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kCmdlineFieldNumber = 4,
    kWorkdingDirectoryFieldNumber = 5,
    kEnvironmentsFieldNumber = 6,
    kConfigFilenameFieldNumber = 7,
    kVersionFieldNumber = 1,
    kStartupTimestampFieldNumber = 8,
    kPidFieldNumber = 2,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string cmdline = 4;
  void clear_cmdline();
  const std::string& cmdline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cmdline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cmdline();
  PROTOBUF_NODISCARD std::string* release_cmdline();
  void set_allocated_cmdline(std::string* cmdline);
  private:
  const std::string& _internal_cmdline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmdline(const std::string& value);
  std::string* _internal_mutable_cmdline();
  public:

  // string workding_directory = 5;
  void clear_workding_directory();
  const std::string& workding_directory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workding_directory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workding_directory();
  PROTOBUF_NODISCARD std::string* release_workding_directory();
  void set_allocated_workding_directory(std::string* workding_directory);
  private:
  const std::string& _internal_workding_directory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workding_directory(const std::string& value);
  std::string* _internal_mutable_workding_directory();
  public:

  // string environments = 6;
  void clear_environments();
  const std::string& environments() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_environments(ArgT0&& arg0, ArgT... args);
  std::string* mutable_environments();
  PROTOBUF_NODISCARD std::string* release_environments();
  void set_allocated_environments(std::string* environments);
  private:
  const std::string& _internal_environments() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_environments(const std::string& value);
  std::string* _internal_mutable_environments();
  public:

  // string config_filename = 7;
  void clear_config_filename();
  const std::string& config_filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_filename();
  PROTOBUF_NODISCARD std::string* release_config_filename();
  void set_allocated_config_filename(std::string* config_filename);
  private:
  const std::string& _internal_config_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_filename(const std::string& value);
  std::string* _internal_mutable_config_filename();
  public:

  // .asf.msgbus.blackbox2.protocol.Version version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::asf::msgbus::blackbox2::protocol::Version& version() const;
  PROTOBUF_NODISCARD ::asf::msgbus::blackbox2::protocol::Version* release_version();
  ::asf::msgbus::blackbox2::protocol::Version* mutable_version();
  void set_allocated_version(::asf::msgbus::blackbox2::protocol::Version* version);
  private:
  const ::asf::msgbus::blackbox2::protocol::Version& _internal_version() const;
  ::asf::msgbus::blackbox2::protocol::Version* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::asf::msgbus::blackbox2::protocol::Version* version);
  ::asf::msgbus::blackbox2::protocol::Version* unsafe_arena_release_version();

  // uint64 startup_timestamp = 8;
  void clear_startup_timestamp();
  uint64_t startup_timestamp() const;
  void set_startup_timestamp(uint64_t value);
  private:
  uint64_t _internal_startup_timestamp() const;
  void _internal_set_startup_timestamp(uint64_t value);
  public:

  // uint32 pid = 2;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.Process)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmdline_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workding_directory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr environments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_filename_;
  ::asf::msgbus::blackbox2::protocol::Version* version_;
  uint64_t startup_timestamp_;
  uint32_t pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Channel_ConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Channel_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Channel_ConfigEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Channel_ConfigEntry_DoNotUse();
  explicit constexpr Channel_ConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Channel_ConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Channel_ConfigEntry_DoNotUse& other);
  static const Channel_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Channel_ConfigEntry_DoNotUse*>(&_Channel_ConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "asf.msgbus.blackbox2.protocol.Channel.ConfigEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "asf.msgbus.blackbox2.protocol.Channel.ConfigEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Channel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.Channel) */ {
 public:
  inline Channel() : Channel(nullptr) {}
  ~Channel() override;
  explicit constexpr Channel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Channel(const Channel& from);
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Channel& operator=(Channel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Channel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }
  inline void Swap(Channel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Channel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Channel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Channel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Channel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Channel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.Channel";
  }
  protected:
  explicit Channel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 6,
    kIdFieldNumber = 3,
    kTypeFieldNumber = 4,
    kOwnerProcessFieldNumber = 1,
    kOwnerThreadFieldNumber = 2,
    kDirFieldNumber = 5,
  };
  // map<string, string> config = 6;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_config();

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string type = 4;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
  bool has_owner_process() const;
  private:
  bool _internal_has_owner_process() const;
  public:
  void clear_owner_process();
  const ::asf::msgbus::blackbox2::protocol::Instance& owner_process() const;
  PROTOBUF_NODISCARD ::asf::msgbus::blackbox2::protocol::Instance* release_owner_process();
  ::asf::msgbus::blackbox2::protocol::Instance* mutable_owner_process();
  void set_allocated_owner_process(::asf::msgbus::blackbox2::protocol::Instance* owner_process);
  private:
  const ::asf::msgbus::blackbox2::protocol::Instance& _internal_owner_process() const;
  ::asf::msgbus::blackbox2::protocol::Instance* _internal_mutable_owner_process();
  public:
  void unsafe_arena_set_allocated_owner_process(
      ::asf::msgbus::blackbox2::protocol::Instance* owner_process);
  ::asf::msgbus::blackbox2::protocol::Instance* unsafe_arena_release_owner_process();

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  bool has_owner_thread() const;
  private:
  bool _internal_has_owner_thread() const;
  public:
  void clear_owner_thread();
  const ::asf::msgbus::blackbox2::protocol::Thread& owner_thread() const;
  PROTOBUF_NODISCARD ::asf::msgbus::blackbox2::protocol::Thread* release_owner_thread();
  ::asf::msgbus::blackbox2::protocol::Thread* mutable_owner_thread();
  void set_allocated_owner_thread(::asf::msgbus::blackbox2::protocol::Thread* owner_thread);
  private:
  const ::asf::msgbus::blackbox2::protocol::Thread& _internal_owner_thread() const;
  ::asf::msgbus::blackbox2::protocol::Thread* _internal_mutable_owner_thread();
  public:
  void unsafe_arena_set_allocated_owner_thread(
      ::asf::msgbus::blackbox2::protocol::Thread* owner_thread);
  ::asf::msgbus::blackbox2::protocol::Thread* unsafe_arena_release_owner_thread();

  // .asf.msgbus.blackbox2.protocol.Direction dir = 5;
  void clear_dir();
  ::asf::msgbus::blackbox2::protocol::Direction dir() const;
  void set_dir(::asf::msgbus::blackbox2::protocol::Direction value);
  private:
  ::asf::msgbus::blackbox2::protocol::Direction _internal_dir() const;
  void _internal_set_dir(::asf::msgbus::blackbox2::protocol::Direction value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.Channel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Channel_ConfigEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::asf::msgbus::blackbox2::protocol::Instance* owner_process_;
  ::asf::msgbus::blackbox2::protocol::Thread* owner_thread_;
  int dir_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Executor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.Executor) */ {
 public:
  inline Executor() : Executor(nullptr) {}
  ~Executor() override;
  explicit constexpr Executor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Executor(const Executor& from);
  Executor(Executor&& from) noexcept
    : Executor() {
    *this = ::std::move(from);
  }

  inline Executor& operator=(const Executor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Executor& operator=(Executor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Executor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Executor* internal_default_instance() {
    return reinterpret_cast<const Executor*>(
               &_Executor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Executor& a, Executor& b) {
    a.Swap(&b);
  }
  inline void Swap(Executor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Executor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Executor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Executor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Executor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Executor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Executor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.Executor";
  }
  protected:
  explicit Executor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachedNodesFieldNumber = 6,
    kOwnerProcessFieldNumber = 1,
    kOwnerThreadFieldNumber = 2,
    kCreateThreadIdFieldNumber = 3,
    kThreadPoolSizeFieldNumber = 4,
    kIsRunnningFieldNumber = 5,
  };
  // repeated string attached_nodes = 6;
  int attached_nodes_size() const;
  private:
  int _internal_attached_nodes_size() const;
  public:
  void clear_attached_nodes();
  const std::string& attached_nodes(int index) const;
  std::string* mutable_attached_nodes(int index);
  void set_attached_nodes(int index, const std::string& value);
  void set_attached_nodes(int index, std::string&& value);
  void set_attached_nodes(int index, const char* value);
  void set_attached_nodes(int index, const char* value, size_t size);
  std::string* add_attached_nodes();
  void add_attached_nodes(const std::string& value);
  void add_attached_nodes(std::string&& value);
  void add_attached_nodes(const char* value);
  void add_attached_nodes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& attached_nodes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_attached_nodes();
  private:
  const std::string& _internal_attached_nodes(int index) const;
  std::string* _internal_add_attached_nodes();
  public:

  // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
  bool has_owner_process() const;
  private:
  bool _internal_has_owner_process() const;
  public:
  void clear_owner_process();
  const ::asf::msgbus::blackbox2::protocol::Instance& owner_process() const;
  PROTOBUF_NODISCARD ::asf::msgbus::blackbox2::protocol::Instance* release_owner_process();
  ::asf::msgbus::blackbox2::protocol::Instance* mutable_owner_process();
  void set_allocated_owner_process(::asf::msgbus::blackbox2::protocol::Instance* owner_process);
  private:
  const ::asf::msgbus::blackbox2::protocol::Instance& _internal_owner_process() const;
  ::asf::msgbus::blackbox2::protocol::Instance* _internal_mutable_owner_process();
  public:
  void unsafe_arena_set_allocated_owner_process(
      ::asf::msgbus::blackbox2::protocol::Instance* owner_process);
  ::asf::msgbus::blackbox2::protocol::Instance* unsafe_arena_release_owner_process();

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  bool has_owner_thread() const;
  private:
  bool _internal_has_owner_thread() const;
  public:
  void clear_owner_thread();
  const ::asf::msgbus::blackbox2::protocol::Thread& owner_thread() const;
  PROTOBUF_NODISCARD ::asf::msgbus::blackbox2::protocol::Thread* release_owner_thread();
  ::asf::msgbus::blackbox2::protocol::Thread* mutable_owner_thread();
  void set_allocated_owner_thread(::asf::msgbus::blackbox2::protocol::Thread* owner_thread);
  private:
  const ::asf::msgbus::blackbox2::protocol::Thread& _internal_owner_thread() const;
  ::asf::msgbus::blackbox2::protocol::Thread* _internal_mutable_owner_thread();
  public:
  void unsafe_arena_set_allocated_owner_thread(
      ::asf::msgbus::blackbox2::protocol::Thread* owner_thread);
  ::asf::msgbus::blackbox2::protocol::Thread* unsafe_arena_release_owner_thread();

  // uint32 create_thread_id = 3;
  void clear_create_thread_id();
  uint32_t create_thread_id() const;
  void set_create_thread_id(uint32_t value);
  private:
  uint32_t _internal_create_thread_id() const;
  void _internal_set_create_thread_id(uint32_t value);
  public:

  // uint32 thread_pool_size = 4;
  void clear_thread_pool_size();
  uint32_t thread_pool_size() const;
  void set_thread_pool_size(uint32_t value);
  private:
  uint32_t _internal_thread_pool_size() const;
  void _internal_set_thread_pool_size(uint32_t value);
  public:

  // bool is_runnning = 5;
  void clear_is_runnning();
  bool is_runnning() const;
  void set_is_runnning(bool value);
  private:
  bool _internal_is_runnning() const;
  void _internal_set_is_runnning(bool value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.Executor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> attached_nodes_;
  ::asf::msgbus::blackbox2::protocol::Instance* owner_process_;
  ::asf::msgbus::blackbox2::protocol::Thread* owner_thread_;
  uint32_t create_thread_id_;
  uint32_t thread_pool_size_;
  bool is_runnning_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class ExecutorTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.ExecutorTask) */ {
 public:
  inline ExecutorTask() : ExecutorTask(nullptr) {}
  ~ExecutorTask() override;
  explicit constexpr ExecutorTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutorTask(const ExecutorTask& from);
  ExecutorTask(ExecutorTask&& from) noexcept
    : ExecutorTask() {
    *this = ::std::move(from);
  }

  inline ExecutorTask& operator=(const ExecutorTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutorTask& operator=(ExecutorTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutorTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutorTask* internal_default_instance() {
    return reinterpret_cast<const ExecutorTask*>(
               &_ExecutorTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ExecutorTask& a, ExecutorTask& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutorTask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutorTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutorTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutorTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutorTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecutorTask& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutorTask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.ExecutorTask";
  }
  protected:
  explicit ExecutorTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreadFieldNumber = 1,
    kTaskIdFieldNumber = 2,
  };
  // .asf.msgbus.blackbox2.protocol.Thread thread = 1;
  bool has_thread() const;
  private:
  bool _internal_has_thread() const;
  public:
  void clear_thread();
  const ::asf::msgbus::blackbox2::protocol::Thread& thread() const;
  PROTOBUF_NODISCARD ::asf::msgbus::blackbox2::protocol::Thread* release_thread();
  ::asf::msgbus::blackbox2::protocol::Thread* mutable_thread();
  void set_allocated_thread(::asf::msgbus::blackbox2::protocol::Thread* thread);
  private:
  const ::asf::msgbus::blackbox2::protocol::Thread& _internal_thread() const;
  ::asf::msgbus::blackbox2::protocol::Thread* _internal_mutable_thread();
  public:
  void unsafe_arena_set_allocated_thread(
      ::asf::msgbus::blackbox2::protocol::Thread* thread);
  ::asf::msgbus::blackbox2::protocol::Thread* unsafe_arena_release_thread();

  // uint32 task_id = 2;
  void clear_task_id();
  uint32_t task_id() const;
  void set_task_id(uint32_t value);
  private:
  uint32_t _internal_task_id() const;
  void _internal_set_task_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.ExecutorTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::asf::msgbus::blackbox2::protocol::Thread* thread_;
  uint32_t task_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit constexpr Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Node& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kOwnerProcessFieldNumber = 1,
    kOwnerThreadFieldNumber = 2,
    kIsAttachedFieldNumber = 4,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
  bool has_owner_process() const;
  private:
  bool _internal_has_owner_process() const;
  public:
  void clear_owner_process();
  const ::asf::msgbus::blackbox2::protocol::Instance& owner_process() const;
  PROTOBUF_NODISCARD ::asf::msgbus::blackbox2::protocol::Instance* release_owner_process();
  ::asf::msgbus::blackbox2::protocol::Instance* mutable_owner_process();
  void set_allocated_owner_process(::asf::msgbus::blackbox2::protocol::Instance* owner_process);
  private:
  const ::asf::msgbus::blackbox2::protocol::Instance& _internal_owner_process() const;
  ::asf::msgbus::blackbox2::protocol::Instance* _internal_mutable_owner_process();
  public:
  void unsafe_arena_set_allocated_owner_process(
      ::asf::msgbus::blackbox2::protocol::Instance* owner_process);
  ::asf::msgbus::blackbox2::protocol::Instance* unsafe_arena_release_owner_process();

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  bool has_owner_thread() const;
  private:
  bool _internal_has_owner_thread() const;
  public:
  void clear_owner_thread();
  const ::asf::msgbus::blackbox2::protocol::Thread& owner_thread() const;
  PROTOBUF_NODISCARD ::asf::msgbus::blackbox2::protocol::Thread* release_owner_thread();
  ::asf::msgbus::blackbox2::protocol::Thread* mutable_owner_thread();
  void set_allocated_owner_thread(::asf::msgbus::blackbox2::protocol::Thread* owner_thread);
  private:
  const ::asf::msgbus::blackbox2::protocol::Thread& _internal_owner_thread() const;
  ::asf::msgbus::blackbox2::protocol::Thread* _internal_mutable_owner_thread();
  public:
  void unsafe_arena_set_allocated_owner_thread(
      ::asf::msgbus::blackbox2::protocol::Thread* owner_thread);
  ::asf::msgbus::blackbox2::protocol::Thread* unsafe_arena_release_owner_thread();

  // bool is_attached = 4;
  void clear_is_attached();
  bool is_attached() const;
  void set_is_attached(bool value);
  private:
  bool _internal_is_attached() const;
  void _internal_set_is_attached(bool value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::asf::msgbus::blackbox2::protocol::Instance* owner_process_;
  ::asf::msgbus::blackbox2::protocol::Thread* owner_thread_;
  bool is_attached_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class KeyStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.KeyStat) */ {
 public:
  inline KeyStat() : KeyStat(nullptr) {}
  ~KeyStat() override;
  explicit constexpr KeyStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyStat(const KeyStat& from);
  KeyStat(KeyStat&& from) noexcept
    : KeyStat() {
    *this = ::std::move(from);
  }

  inline KeyStat& operator=(const KeyStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyStat& operator=(KeyStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyStat* internal_default_instance() {
    return reinterpret_cast<const KeyStat*>(
               &_KeyStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(KeyStat& a, KeyStat& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeyStat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.KeyStat";
  }
  protected:
  explicit KeyStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRxSubscriberFieldNumber = 2,
    kRxUnsubscriberFieldNumber = 3,
    kRxPacketsFieldNumber = 4,
    kRxBytesFieldNumber = 5,
    kRxMulticastFieldNumber = 6,
    kRxLengthErrorsFieldNumber = 7,
    kRxNoBufferFieldNumber = 8,
    kRxNoReaderFieldNumber = 9,
    kTxSubscriberFieldNumber = 10,
    kTxUnsubscriberFieldNumber = 11,
    kTxPacketsFieldNumber = 12,
    kTxBytesFieldNumber = 13,
    kTxMulticastFieldNumber = 14,
    kTxNoTransmitFieldNumber = 15,
    kTxLengthErrorsFieldNumber = 16,
    kTxNoChannelFieldNumber = 17,
    kTxNoSubscriberFieldNumber = 18,
    kTxNoEndpointFieldNumber = 19,
    kTxNoBufferFieldNumber = 20,
    kValidFieldNumber = 1,
  };
  // uint64 rx_subscriber = 2;
  void clear_rx_subscriber();
  uint64_t rx_subscriber() const;
  void set_rx_subscriber(uint64_t value);
  private:
  uint64_t _internal_rx_subscriber() const;
  void _internal_set_rx_subscriber(uint64_t value);
  public:

  // uint64 rx_unsubscriber = 3;
  void clear_rx_unsubscriber();
  uint64_t rx_unsubscriber() const;
  void set_rx_unsubscriber(uint64_t value);
  private:
  uint64_t _internal_rx_unsubscriber() const;
  void _internal_set_rx_unsubscriber(uint64_t value);
  public:

  // uint64 rx_packets = 4;
  void clear_rx_packets();
  uint64_t rx_packets() const;
  void set_rx_packets(uint64_t value);
  private:
  uint64_t _internal_rx_packets() const;
  void _internal_set_rx_packets(uint64_t value);
  public:

  // uint64 rx_bytes = 5;
  void clear_rx_bytes();
  uint64_t rx_bytes() const;
  void set_rx_bytes(uint64_t value);
  private:
  uint64_t _internal_rx_bytes() const;
  void _internal_set_rx_bytes(uint64_t value);
  public:

  // uint64 rx_multicast = 6;
  void clear_rx_multicast();
  uint64_t rx_multicast() const;
  void set_rx_multicast(uint64_t value);
  private:
  uint64_t _internal_rx_multicast() const;
  void _internal_set_rx_multicast(uint64_t value);
  public:

  // uint64 rx_length_errors = 7;
  void clear_rx_length_errors();
  uint64_t rx_length_errors() const;
  void set_rx_length_errors(uint64_t value);
  private:
  uint64_t _internal_rx_length_errors() const;
  void _internal_set_rx_length_errors(uint64_t value);
  public:

  // uint64 rx_no_buffer = 8;
  void clear_rx_no_buffer();
  uint64_t rx_no_buffer() const;
  void set_rx_no_buffer(uint64_t value);
  private:
  uint64_t _internal_rx_no_buffer() const;
  void _internal_set_rx_no_buffer(uint64_t value);
  public:

  // uint64 rx_no_reader = 9;
  void clear_rx_no_reader();
  uint64_t rx_no_reader() const;
  void set_rx_no_reader(uint64_t value);
  private:
  uint64_t _internal_rx_no_reader() const;
  void _internal_set_rx_no_reader(uint64_t value);
  public:

  // uint64 tx_subscriber = 10;
  void clear_tx_subscriber();
  uint64_t tx_subscriber() const;
  void set_tx_subscriber(uint64_t value);
  private:
  uint64_t _internal_tx_subscriber() const;
  void _internal_set_tx_subscriber(uint64_t value);
  public:

  // uint64 tx_unsubscriber = 11;
  void clear_tx_unsubscriber();
  uint64_t tx_unsubscriber() const;
  void set_tx_unsubscriber(uint64_t value);
  private:
  uint64_t _internal_tx_unsubscriber() const;
  void _internal_set_tx_unsubscriber(uint64_t value);
  public:

  // uint64 tx_packets = 12;
  void clear_tx_packets();
  uint64_t tx_packets() const;
  void set_tx_packets(uint64_t value);
  private:
  uint64_t _internal_tx_packets() const;
  void _internal_set_tx_packets(uint64_t value);
  public:

  // uint64 tx_bytes = 13;
  void clear_tx_bytes();
  uint64_t tx_bytes() const;
  void set_tx_bytes(uint64_t value);
  private:
  uint64_t _internal_tx_bytes() const;
  void _internal_set_tx_bytes(uint64_t value);
  public:

  // uint64 tx_multicast = 14;
  void clear_tx_multicast();
  uint64_t tx_multicast() const;
  void set_tx_multicast(uint64_t value);
  private:
  uint64_t _internal_tx_multicast() const;
  void _internal_set_tx_multicast(uint64_t value);
  public:

  // uint64 tx_no_transmit = 15;
  void clear_tx_no_transmit();
  uint64_t tx_no_transmit() const;
  void set_tx_no_transmit(uint64_t value);
  private:
  uint64_t _internal_tx_no_transmit() const;
  void _internal_set_tx_no_transmit(uint64_t value);
  public:

  // uint64 tx_length_errors = 16;
  void clear_tx_length_errors();
  uint64_t tx_length_errors() const;
  void set_tx_length_errors(uint64_t value);
  private:
  uint64_t _internal_tx_length_errors() const;
  void _internal_set_tx_length_errors(uint64_t value);
  public:

  // uint64 tx_no_channel = 17;
  void clear_tx_no_channel();
  uint64_t tx_no_channel() const;
  void set_tx_no_channel(uint64_t value);
  private:
  uint64_t _internal_tx_no_channel() const;
  void _internal_set_tx_no_channel(uint64_t value);
  public:

  // uint64 tx_no_subscriber = 18;
  void clear_tx_no_subscriber();
  uint64_t tx_no_subscriber() const;
  void set_tx_no_subscriber(uint64_t value);
  private:
  uint64_t _internal_tx_no_subscriber() const;
  void _internal_set_tx_no_subscriber(uint64_t value);
  public:

  // uint64 tx_no_endpoint = 19;
  void clear_tx_no_endpoint();
  uint64_t tx_no_endpoint() const;
  void set_tx_no_endpoint(uint64_t value);
  private:
  uint64_t _internal_tx_no_endpoint() const;
  void _internal_set_tx_no_endpoint(uint64_t value);
  public:

  // uint64 tx_no_buffer = 20;
  void clear_tx_no_buffer();
  uint64_t tx_no_buffer() const;
  void set_tx_no_buffer(uint64_t value);
  private:
  uint64_t _internal_tx_no_buffer() const;
  void _internal_set_tx_no_buffer(uint64_t value);
  public:

  // bool valid = 1;
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.KeyStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t rx_subscriber_;
  uint64_t rx_unsubscriber_;
  uint64_t rx_packets_;
  uint64_t rx_bytes_;
  uint64_t rx_multicast_;
  uint64_t rx_length_errors_;
  uint64_t rx_no_buffer_;
  uint64_t rx_no_reader_;
  uint64_t tx_subscriber_;
  uint64_t tx_unsubscriber_;
  uint64_t tx_packets_;
  uint64_t tx_bytes_;
  uint64_t tx_multicast_;
  uint64_t tx_no_transmit_;
  uint64_t tx_length_errors_;
  uint64_t tx_no_channel_;
  uint64_t tx_no_subscriber_;
  uint64_t tx_no_endpoint_;
  uint64_t tx_no_buffer_;
  bool valid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Handle_MappingChannelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Handle_MappingChannelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Handle_MappingChannelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Handle_MappingChannelsEntry_DoNotUse();
  explicit constexpr Handle_MappingChannelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Handle_MappingChannelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Handle_MappingChannelsEntry_DoNotUse& other);
  static const Handle_MappingChannelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Handle_MappingChannelsEntry_DoNotUse*>(&_Handle_MappingChannelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "asf.msgbus.blackbox2.protocol.Handle.MappingChannelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "asf.msgbus.blackbox2.protocol.Handle.MappingChannelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Handle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.Handle) */ {
 public:
  inline Handle() : Handle(nullptr) {}
  ~Handle() override;
  explicit constexpr Handle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Handle(const Handle& from);
  Handle(Handle&& from) noexcept
    : Handle() {
    *this = ::std::move(from);
  }

  inline Handle& operator=(const Handle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Handle& operator=(Handle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Handle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Handle* internal_default_instance() {
    return reinterpret_cast<const Handle*>(
               &_Handle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Handle& a, Handle& b) {
    a.Swap(&b);
  }
  inline void Swap(Handle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Handle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Handle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Handle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Handle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Handle& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Handle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.Handle";
  }
  protected:
  explicit Handle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMappingChannelsFieldNumber = 6,
    kKeyFieldNumber = 4,
    kOwnerNodeFieldNumber = 1,
    kOwnerThreadFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIsEnabledFieldNumber = 5,
  };
  // map<string, string> mapping_channels = 6;
  int mapping_channels_size() const;
  private:
  int _internal_mapping_channels_size() const;
  public:
  void clear_mapping_channels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_mapping_channels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_mapping_channels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      mapping_channels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_mapping_channels();

  // string key = 4;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .asf.msgbus.blackbox2.protocol.Instance owner_node = 1;
  bool has_owner_node() const;
  private:
  bool _internal_has_owner_node() const;
  public:
  void clear_owner_node();
  const ::asf::msgbus::blackbox2::protocol::Instance& owner_node() const;
  PROTOBUF_NODISCARD ::asf::msgbus::blackbox2::protocol::Instance* release_owner_node();
  ::asf::msgbus::blackbox2::protocol::Instance* mutable_owner_node();
  void set_allocated_owner_node(::asf::msgbus::blackbox2::protocol::Instance* owner_node);
  private:
  const ::asf::msgbus::blackbox2::protocol::Instance& _internal_owner_node() const;
  ::asf::msgbus::blackbox2::protocol::Instance* _internal_mutable_owner_node();
  public:
  void unsafe_arena_set_allocated_owner_node(
      ::asf::msgbus::blackbox2::protocol::Instance* owner_node);
  ::asf::msgbus::blackbox2::protocol::Instance* unsafe_arena_release_owner_node();

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  bool has_owner_thread() const;
  private:
  bool _internal_has_owner_thread() const;
  public:
  void clear_owner_thread();
  const ::asf::msgbus::blackbox2::protocol::Thread& owner_thread() const;
  PROTOBUF_NODISCARD ::asf::msgbus::blackbox2::protocol::Thread* release_owner_thread();
  ::asf::msgbus::blackbox2::protocol::Thread* mutable_owner_thread();
  void set_allocated_owner_thread(::asf::msgbus::blackbox2::protocol::Thread* owner_thread);
  private:
  const ::asf::msgbus::blackbox2::protocol::Thread& _internal_owner_thread() const;
  ::asf::msgbus::blackbox2::protocol::Thread* _internal_mutable_owner_thread();
  public:
  void unsafe_arena_set_allocated_owner_thread(
      ::asf::msgbus::blackbox2::protocol::Thread* owner_thread);
  ::asf::msgbus::blackbox2::protocol::Thread* unsafe_arena_release_owner_thread();

  // .asf.msgbus.blackbox2.protocol.HandleType type = 3;
  void clear_type();
  ::asf::msgbus::blackbox2::protocol::HandleType type() const;
  void set_type(::asf::msgbus::blackbox2::protocol::HandleType value);
  private:
  ::asf::msgbus::blackbox2::protocol::HandleType _internal_type() const;
  void _internal_set_type(::asf::msgbus::blackbox2::protocol::HandleType value);
  public:

  // bool is_enabled = 5;
  void clear_is_enabled();
  bool is_enabled() const;
  void set_is_enabled(bool value);
  private:
  bool _internal_is_enabled() const;
  void _internal_set_is_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.Handle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Handle_MappingChannelsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> mapping_channels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::asf::msgbus::blackbox2::protocol::Instance* owner_node_;
  ::asf::msgbus::blackbox2::protocol::Thread* owner_thread_;
  int type_;
  bool is_enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class AttachResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.AttachResponse) */ {
 public:
  inline AttachResponse() : AttachResponse(nullptr) {}
  ~AttachResponse() override;
  explicit constexpr AttachResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttachResponse(const AttachResponse& from);
  AttachResponse(AttachResponse&& from) noexcept
    : AttachResponse() {
    *this = ::std::move(from);
  }

  inline AttachResponse& operator=(const AttachResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttachResponse& operator=(AttachResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttachResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttachResponse* internal_default_instance() {
    return reinterpret_cast<const AttachResponse*>(
               &_AttachResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AttachResponse& a, AttachResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AttachResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttachResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttachResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttachResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttachResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AttachResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttachResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.AttachResponse";
  }
  protected:
  explicit AttachResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceFieldNumber = 1,
    kIsActivatedFieldNumber = 2,
  };
  // .asf.msgbus.blackbox2.protocol.Instance instance = 1;
  bool has_instance() const;
  private:
  bool _internal_has_instance() const;
  public:
  void clear_instance();
  const ::asf::msgbus::blackbox2::protocol::Instance& instance() const;
  PROTOBUF_NODISCARD ::asf::msgbus::blackbox2::protocol::Instance* release_instance();
  ::asf::msgbus::blackbox2::protocol::Instance* mutable_instance();
  void set_allocated_instance(::asf::msgbus::blackbox2::protocol::Instance* instance);
  private:
  const ::asf::msgbus::blackbox2::protocol::Instance& _internal_instance() const;
  ::asf::msgbus::blackbox2::protocol::Instance* _internal_mutable_instance();
  public:
  void unsafe_arena_set_allocated_instance(
      ::asf::msgbus::blackbox2::protocol::Instance* instance);
  ::asf::msgbus::blackbox2::protocol::Instance* unsafe_arena_release_instance();

  // bool is_activated = 2;
  void clear_is_activated();
  bool is_activated() const;
  void set_is_activated(bool value);
  private:
  bool _internal_is_activated() const;
  void _internal_set_is_activated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.AttachResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::asf::msgbus::blackbox2::protocol::Instance* instance_;
  bool is_activated_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit constexpr Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kSerializeTypeFieldNumber = 4,
    kDirFieldNumber = 1,
    kIsPodFieldNumber = 3,
    kGenTimestampFieldNumber = 5,
    kTxTimestampFieldNumber = 6,
    kRxTimestampFieldNumber = 7,
    kWriteTimestampFieldNumber = 8,
    kReadTimestampFieldNumber = 9,
  };
  // optional bytes payload = 2;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // optional string serialize_type = 4;
  bool has_serialize_type() const;
  private:
  bool _internal_has_serialize_type() const;
  public:
  void clear_serialize_type();
  const std::string& serialize_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialize_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialize_type();
  PROTOBUF_NODISCARD std::string* release_serialize_type();
  void set_allocated_serialize_type(std::string* serialize_type);
  private:
  const std::string& _internal_serialize_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialize_type(const std::string& value);
  std::string* _internal_mutable_serialize_type();
  public:

  // .asf.msgbus.blackbox2.protocol.Direction dir = 1;
  void clear_dir();
  ::asf::msgbus::blackbox2::protocol::Direction dir() const;
  void set_dir(::asf::msgbus::blackbox2::protocol::Direction value);
  private:
  ::asf::msgbus::blackbox2::protocol::Direction _internal_dir() const;
  void _internal_set_dir(::asf::msgbus::blackbox2::protocol::Direction value);
  public:

  // optional bool is_pod = 3;
  bool has_is_pod() const;
  private:
  bool _internal_has_is_pod() const;
  public:
  void clear_is_pod();
  bool is_pod() const;
  void set_is_pod(bool value);
  private:
  bool _internal_is_pod() const;
  void _internal_set_is_pod(bool value);
  public:

  // optional uint64 gen_timestamp = 5;
  bool has_gen_timestamp() const;
  private:
  bool _internal_has_gen_timestamp() const;
  public:
  void clear_gen_timestamp();
  uint64_t gen_timestamp() const;
  void set_gen_timestamp(uint64_t value);
  private:
  uint64_t _internal_gen_timestamp() const;
  void _internal_set_gen_timestamp(uint64_t value);
  public:

  // optional uint64 tx_timestamp = 6;
  bool has_tx_timestamp() const;
  private:
  bool _internal_has_tx_timestamp() const;
  public:
  void clear_tx_timestamp();
  uint64_t tx_timestamp() const;
  void set_tx_timestamp(uint64_t value);
  private:
  uint64_t _internal_tx_timestamp() const;
  void _internal_set_tx_timestamp(uint64_t value);
  public:

  // optional uint64 rx_timestamp = 7;
  bool has_rx_timestamp() const;
  private:
  bool _internal_has_rx_timestamp() const;
  public:
  void clear_rx_timestamp();
  uint64_t rx_timestamp() const;
  void set_rx_timestamp(uint64_t value);
  private:
  uint64_t _internal_rx_timestamp() const;
  void _internal_set_rx_timestamp(uint64_t value);
  public:

  // optional uint64 write_timestamp = 8;
  bool has_write_timestamp() const;
  private:
  bool _internal_has_write_timestamp() const;
  public:
  void clear_write_timestamp();
  uint64_t write_timestamp() const;
  void set_write_timestamp(uint64_t value);
  private:
  uint64_t _internal_write_timestamp() const;
  void _internal_set_write_timestamp(uint64_t value);
  public:

  // optional uint64 read_timestamp = 9;
  bool has_read_timestamp() const;
  private:
  bool _internal_has_read_timestamp() const;
  public:
  void clear_read_timestamp();
  uint64_t read_timestamp() const;
  void set_read_timestamp(uint64_t value);
  private:
  uint64_t _internal_read_timestamp() const;
  void _internal_set_read_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialize_type_;
  int dir_;
  bool is_pod_;
  uint64_t gen_timestamp_;
  uint64_t tx_timestamp_;
  uint64_t rx_timestamp_;
  uint64_t write_timestamp_;
  uint64_t read_timestamp_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class MessageFields final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:asf.msgbus.blackbox2.protocol.MessageFields) */ {
 public:
  inline MessageFields() : MessageFields(nullptr) {}
  ~MessageFields() override;
  explicit constexpr MessageFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageFields(const MessageFields& from);
  MessageFields(MessageFields&& from) noexcept
    : MessageFields() {
    *this = ::std::move(from);
  }

  inline MessageFields& operator=(const MessageFields& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageFields& operator=(MessageFields&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageFields& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageFields* internal_default_instance() {
    return reinterpret_cast<const MessageFields*>(
               &_MessageFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MessageFields& a, MessageFields& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageFields* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageFields* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageFields>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageFields& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MessageFields& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageFields* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "asf.msgbus.blackbox2.protocol.MessageFields";
  }
  protected:
  explicit MessageFields(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHasFlagsFieldNumber = 1,
  };
  // uint32 has_flags = 1;
  void clear_has_flags();
  uint32_t has_flags() const;
  void set_has_flags(uint32_t value);
  private:
  uint32_t _internal_has_flags() const;
  void _internal_set_has_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:asf.msgbus.blackbox2.protocol.MessageFields)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t has_flags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_5fmessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Boolean

// bool value = 1;
inline void Boolean::clear_value() {
  value_ = false;
}
inline bool Boolean::_internal_value() const {
  return value_;
}
inline bool Boolean::value() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Boolean.value)
  return _internal_value();
}
inline void Boolean::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void Boolean::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Boolean.value)
}

// -------------------------------------------------------------------

// String

// string value = 1;
inline void String::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& String::value() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.String.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void String::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.String.value)
}
inline std::string* String::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.String.value)
  return _s;
}
inline const std::string& String::_internal_value() const {
  return value_.Get();
}
inline void String::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* String::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* String::release_value() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.String.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void String::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.String.value)
}

// -------------------------------------------------------------------

// Instance

// uint64 id = 1;
inline void Instance::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Instance::_internal_id() const {
  return id_;
}
inline uint64_t Instance::id() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Instance.id)
  return _internal_id();
}
inline void Instance::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Instance::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Instance.id)
}

// -------------------------------------------------------------------

// Result

// uint32 code = 1;
inline void Result::clear_code() {
  code_ = 0u;
}
inline uint32_t Result::_internal_code() const {
  return code_;
}
inline uint32_t Result::code() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Result.code)
  return _internal_code();
}
inline void Result::_internal_set_code(uint32_t value) {
  
  code_ = value;
}
inline void Result::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Result.code)
}

// -------------------------------------------------------------------

// Version

// uint32 major_number = 1;
inline void Version::clear_major_number() {
  major_number_ = 0u;
}
inline uint32_t Version::_internal_major_number() const {
  return major_number_;
}
inline uint32_t Version::major_number() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Version.major_number)
  return _internal_major_number();
}
inline void Version::_internal_set_major_number(uint32_t value) {
  
  major_number_ = value;
}
inline void Version::set_major_number(uint32_t value) {
  _internal_set_major_number(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Version.major_number)
}

// uint32 minor_number = 2;
inline void Version::clear_minor_number() {
  minor_number_ = 0u;
}
inline uint32_t Version::_internal_minor_number() const {
  return minor_number_;
}
inline uint32_t Version::minor_number() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Version.minor_number)
  return _internal_minor_number();
}
inline void Version::_internal_set_minor_number(uint32_t value) {
  
  minor_number_ = value;
}
inline void Version::set_minor_number(uint32_t value) {
  _internal_set_minor_number(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Version.minor_number)
}

// uint32 patch_number = 3;
inline void Version::clear_patch_number() {
  patch_number_ = 0u;
}
inline uint32_t Version::_internal_patch_number() const {
  return patch_number_;
}
inline uint32_t Version::patch_number() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Version.patch_number)
  return _internal_patch_number();
}
inline void Version::_internal_set_patch_number(uint32_t value) {
  
  patch_number_ = value;
}
inline void Version::set_patch_number(uint32_t value) {
  _internal_set_patch_number(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Version.patch_number)
}

// -------------------------------------------------------------------

// Thread

// uint64 id = 1;
inline void Thread::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Thread::_internal_id() const {
  return id_;
}
inline uint64_t Thread::id() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Thread.id)
  return _internal_id();
}
inline void Thread::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Thread::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Thread.id)
}

// string name = 2;
inline void Thread::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Thread::name() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Thread.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Thread::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Thread.name)
}
inline std::string* Thread::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Thread.name)
  return _s;
}
inline const std::string& Thread::_internal_name() const {
  return name_.Get();
}
inline void Thread::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Thread::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Thread::release_name() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Thread.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Thread::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Thread.name)
}

// -------------------------------------------------------------------

// Process

// .asf.msgbus.blackbox2.protocol.Version version = 1;
inline bool Process::_internal_has_version() const {
  return this != internal_default_instance() && version_ != nullptr;
}
inline bool Process::has_version() const {
  return _internal_has_version();
}
inline void Process::clear_version() {
  if (GetArenaForAllocation() == nullptr && version_ != nullptr) {
    delete version_;
  }
  version_ = nullptr;
}
inline const ::asf::msgbus::blackbox2::protocol::Version& Process::_internal_version() const {
  const ::asf::msgbus::blackbox2::protocol::Version* p = version_;
  return p != nullptr ? *p : reinterpret_cast<const ::asf::msgbus::blackbox2::protocol::Version&>(
      ::asf::msgbus::blackbox2::protocol::_Version_default_instance_);
}
inline const ::asf::msgbus::blackbox2::protocol::Version& Process::version() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Process.version)
  return _internal_version();
}
inline void Process::unsafe_arena_set_allocated_version(
    ::asf::msgbus::blackbox2::protocol::Version* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:asf.msgbus.blackbox2.protocol.Process.version)
}
inline ::asf::msgbus::blackbox2::protocol::Version* Process::release_version() {
  
  ::asf::msgbus::blackbox2::protocol::Version* temp = version_;
  version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Version* Process::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Process.version)
  
  ::asf::msgbus::blackbox2::protocol::Version* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Version* Process::_internal_mutable_version() {
  
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Version>(GetArenaForAllocation());
    version_ = p;
  }
  return version_;
}
inline ::asf::msgbus::blackbox2::protocol::Version* Process::mutable_version() {
  ::asf::msgbus::blackbox2::protocol::Version* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Process.version)
  return _msg;
}
inline void Process::set_allocated_version(::asf::msgbus::blackbox2::protocol::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::asf::msgbus::blackbox2::protocol::Version>::GetOwningArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Process.version)
}

// uint32 pid = 2;
inline void Process::clear_pid() {
  pid_ = 0u;
}
inline uint32_t Process::_internal_pid() const {
  return pid_;
}
inline uint32_t Process::pid() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Process.pid)
  return _internal_pid();
}
inline void Process::_internal_set_pid(uint32_t value) {
  
  pid_ = value;
}
inline void Process::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Process.pid)
}

// string name = 3;
inline void Process::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Process::name() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Process.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Process.name)
}
inline std::string* Process::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Process.name)
  return _s;
}
inline const std::string& Process::_internal_name() const {
  return name_.Get();
}
inline void Process::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Process::release_name() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Process.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Process::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Process.name)
}

// string cmdline = 4;
inline void Process::clear_cmdline() {
  cmdline_.ClearToEmpty();
}
inline const std::string& Process::cmdline() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Process.cmdline)
  return _internal_cmdline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_cmdline(ArgT0&& arg0, ArgT... args) {
 
 cmdline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Process.cmdline)
}
inline std::string* Process::mutable_cmdline() {
  std::string* _s = _internal_mutable_cmdline();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Process.cmdline)
  return _s;
}
inline const std::string& Process::_internal_cmdline() const {
  return cmdline_.Get();
}
inline void Process::_internal_set_cmdline(const std::string& value) {
  
  cmdline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_cmdline() {
  
  return cmdline_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Process::release_cmdline() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Process.cmdline)
  return cmdline_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Process::set_allocated_cmdline(std::string* cmdline) {
  if (cmdline != nullptr) {
    
  } else {
    
  }
  cmdline_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cmdline,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cmdline_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cmdline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Process.cmdline)
}

// string workding_directory = 5;
inline void Process::clear_workding_directory() {
  workding_directory_.ClearToEmpty();
}
inline const std::string& Process::workding_directory() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Process.workding_directory)
  return _internal_workding_directory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_workding_directory(ArgT0&& arg0, ArgT... args) {
 
 workding_directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Process.workding_directory)
}
inline std::string* Process::mutable_workding_directory() {
  std::string* _s = _internal_mutable_workding_directory();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Process.workding_directory)
  return _s;
}
inline const std::string& Process::_internal_workding_directory() const {
  return workding_directory_.Get();
}
inline void Process::_internal_set_workding_directory(const std::string& value) {
  
  workding_directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_workding_directory() {
  
  return workding_directory_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Process::release_workding_directory() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Process.workding_directory)
  return workding_directory_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Process::set_allocated_workding_directory(std::string* workding_directory) {
  if (workding_directory != nullptr) {
    
  } else {
    
  }
  workding_directory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), workding_directory,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (workding_directory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    workding_directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Process.workding_directory)
}

// string environments = 6;
inline void Process::clear_environments() {
  environments_.ClearToEmpty();
}
inline const std::string& Process::environments() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Process.environments)
  return _internal_environments();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_environments(ArgT0&& arg0, ArgT... args) {
 
 environments_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Process.environments)
}
inline std::string* Process::mutable_environments() {
  std::string* _s = _internal_mutable_environments();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Process.environments)
  return _s;
}
inline const std::string& Process::_internal_environments() const {
  return environments_.Get();
}
inline void Process::_internal_set_environments(const std::string& value) {
  
  environments_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_environments() {
  
  return environments_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Process::release_environments() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Process.environments)
  return environments_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Process::set_allocated_environments(std::string* environments) {
  if (environments != nullptr) {
    
  } else {
    
  }
  environments_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), environments,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (environments_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    environments_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Process.environments)
}

// string config_filename = 7;
inline void Process::clear_config_filename() {
  config_filename_.ClearToEmpty();
}
inline const std::string& Process::config_filename() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Process.config_filename)
  return _internal_config_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_config_filename(ArgT0&& arg0, ArgT... args) {
 
 config_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Process.config_filename)
}
inline std::string* Process::mutable_config_filename() {
  std::string* _s = _internal_mutable_config_filename();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Process.config_filename)
  return _s;
}
inline const std::string& Process::_internal_config_filename() const {
  return config_filename_.Get();
}
inline void Process::_internal_set_config_filename(const std::string& value) {
  
  config_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_config_filename() {
  
  return config_filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Process::release_config_filename() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Process.config_filename)
  return config_filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Process::set_allocated_config_filename(std::string* config_filename) {
  if (config_filename != nullptr) {
    
  } else {
    
  }
  config_filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config_filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (config_filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    config_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Process.config_filename)
}

// uint64 startup_timestamp = 8;
inline void Process::clear_startup_timestamp() {
  startup_timestamp_ = uint64_t{0u};
}
inline uint64_t Process::_internal_startup_timestamp() const {
  return startup_timestamp_;
}
inline uint64_t Process::startup_timestamp() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Process.startup_timestamp)
  return _internal_startup_timestamp();
}
inline void Process::_internal_set_startup_timestamp(uint64_t value) {
  
  startup_timestamp_ = value;
}
inline void Process::set_startup_timestamp(uint64_t value) {
  _internal_set_startup_timestamp(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Process.startup_timestamp)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Channel

// .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
inline bool Channel::_internal_has_owner_process() const {
  return this != internal_default_instance() && owner_process_ != nullptr;
}
inline bool Channel::has_owner_process() const {
  return _internal_has_owner_process();
}
inline void Channel::clear_owner_process() {
  if (GetArenaForAllocation() == nullptr && owner_process_ != nullptr) {
    delete owner_process_;
  }
  owner_process_ = nullptr;
}
inline const ::asf::msgbus::blackbox2::protocol::Instance& Channel::_internal_owner_process() const {
  const ::asf::msgbus::blackbox2::protocol::Instance* p = owner_process_;
  return p != nullptr ? *p : reinterpret_cast<const ::asf::msgbus::blackbox2::protocol::Instance&>(
      ::asf::msgbus::blackbox2::protocol::_Instance_default_instance_);
}
inline const ::asf::msgbus::blackbox2::protocol::Instance& Channel::owner_process() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Channel.owner_process)
  return _internal_owner_process();
}
inline void Channel::unsafe_arena_set_allocated_owner_process(
    ::asf::msgbus::blackbox2::protocol::Instance* owner_process) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_process_);
  }
  owner_process_ = owner_process;
  if (owner_process) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:asf.msgbus.blackbox2.protocol.Channel.owner_process)
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Channel::release_owner_process() {
  
  ::asf::msgbus::blackbox2::protocol::Instance* temp = owner_process_;
  owner_process_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Channel::unsafe_arena_release_owner_process() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Channel.owner_process)
  
  ::asf::msgbus::blackbox2::protocol::Instance* temp = owner_process_;
  owner_process_ = nullptr;
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Channel::_internal_mutable_owner_process() {
  
  if (owner_process_ == nullptr) {
    auto* p = CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Instance>(GetArenaForAllocation());
    owner_process_ = p;
  }
  return owner_process_;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Channel::mutable_owner_process() {
  ::asf::msgbus::blackbox2::protocol::Instance* _msg = _internal_mutable_owner_process();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Channel.owner_process)
  return _msg;
}
inline void Channel::set_allocated_owner_process(::asf::msgbus::blackbox2::protocol::Instance* owner_process) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete owner_process_;
  }
  if (owner_process) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::asf::msgbus::blackbox2::protocol::Instance>::GetOwningArena(owner_process);
    if (message_arena != submessage_arena) {
      owner_process = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_process, submessage_arena);
    }
    
  } else {
    
  }
  owner_process_ = owner_process;
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Channel.owner_process)
}

// .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
inline bool Channel::_internal_has_owner_thread() const {
  return this != internal_default_instance() && owner_thread_ != nullptr;
}
inline bool Channel::has_owner_thread() const {
  return _internal_has_owner_thread();
}
inline void Channel::clear_owner_thread() {
  if (GetArenaForAllocation() == nullptr && owner_thread_ != nullptr) {
    delete owner_thread_;
  }
  owner_thread_ = nullptr;
}
inline const ::asf::msgbus::blackbox2::protocol::Thread& Channel::_internal_owner_thread() const {
  const ::asf::msgbus::blackbox2::protocol::Thread* p = owner_thread_;
  return p != nullptr ? *p : reinterpret_cast<const ::asf::msgbus::blackbox2::protocol::Thread&>(
      ::asf::msgbus::blackbox2::protocol::_Thread_default_instance_);
}
inline const ::asf::msgbus::blackbox2::protocol::Thread& Channel::owner_thread() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Channel.owner_thread)
  return _internal_owner_thread();
}
inline void Channel::unsafe_arena_set_allocated_owner_thread(
    ::asf::msgbus::blackbox2::protocol::Thread* owner_thread) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_thread_);
  }
  owner_thread_ = owner_thread;
  if (owner_thread) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:asf.msgbus.blackbox2.protocol.Channel.owner_thread)
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Channel::release_owner_thread() {
  
  ::asf::msgbus::blackbox2::protocol::Thread* temp = owner_thread_;
  owner_thread_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Channel::unsafe_arena_release_owner_thread() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Channel.owner_thread)
  
  ::asf::msgbus::blackbox2::protocol::Thread* temp = owner_thread_;
  owner_thread_ = nullptr;
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Channel::_internal_mutable_owner_thread() {
  
  if (owner_thread_ == nullptr) {
    auto* p = CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Thread>(GetArenaForAllocation());
    owner_thread_ = p;
  }
  return owner_thread_;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Channel::mutable_owner_thread() {
  ::asf::msgbus::blackbox2::protocol::Thread* _msg = _internal_mutable_owner_thread();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Channel.owner_thread)
  return _msg;
}
inline void Channel::set_allocated_owner_thread(::asf::msgbus::blackbox2::protocol::Thread* owner_thread) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete owner_thread_;
  }
  if (owner_thread) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::asf::msgbus::blackbox2::protocol::Thread>::GetOwningArena(owner_thread);
    if (message_arena != submessage_arena) {
      owner_thread = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_thread, submessage_arena);
    }
    
  } else {
    
  }
  owner_thread_ = owner_thread;
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Channel.owner_thread)
}

// string id = 3;
inline void Channel::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Channel::id() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Channel.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Channel::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Channel.id)
}
inline std::string* Channel::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Channel.id)
  return _s;
}
inline const std::string& Channel::_internal_id() const {
  return id_.Get();
}
inline void Channel::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Channel::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Channel::release_id() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Channel.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Channel::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Channel.id)
}

// string type = 4;
inline void Channel::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Channel::type() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Channel.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Channel::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Channel.type)
}
inline std::string* Channel::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Channel.type)
  return _s;
}
inline const std::string& Channel::_internal_type() const {
  return type_.Get();
}
inline void Channel::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Channel::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Channel::release_type() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Channel.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Channel::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Channel.type)
}

// .asf.msgbus.blackbox2.protocol.Direction dir = 5;
inline void Channel::clear_dir() {
  dir_ = 0;
}
inline ::asf::msgbus::blackbox2::protocol::Direction Channel::_internal_dir() const {
  return static_cast< ::asf::msgbus::blackbox2::protocol::Direction >(dir_);
}
inline ::asf::msgbus::blackbox2::protocol::Direction Channel::dir() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Channel.dir)
  return _internal_dir();
}
inline void Channel::_internal_set_dir(::asf::msgbus::blackbox2::protocol::Direction value) {
  
  dir_ = value;
}
inline void Channel::set_dir(::asf::msgbus::blackbox2::protocol::Direction value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Channel.dir)
}

// map<string, string> config = 6;
inline int Channel::_internal_config_size() const {
  return config_.size();
}
inline int Channel::config_size() const {
  return _internal_config_size();
}
inline void Channel::clear_config() {
  config_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Channel::_internal_config() const {
  return config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Channel::config() const {
  // @@protoc_insertion_point(field_map:asf.msgbus.blackbox2.protocol.Channel.config)
  return _internal_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Channel::_internal_mutable_config() {
  return config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Channel::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:asf.msgbus.blackbox2.protocol.Channel.config)
  return _internal_mutable_config();
}

// -------------------------------------------------------------------

// Executor

// .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
inline bool Executor::_internal_has_owner_process() const {
  return this != internal_default_instance() && owner_process_ != nullptr;
}
inline bool Executor::has_owner_process() const {
  return _internal_has_owner_process();
}
inline void Executor::clear_owner_process() {
  if (GetArenaForAllocation() == nullptr && owner_process_ != nullptr) {
    delete owner_process_;
  }
  owner_process_ = nullptr;
}
inline const ::asf::msgbus::blackbox2::protocol::Instance& Executor::_internal_owner_process() const {
  const ::asf::msgbus::blackbox2::protocol::Instance* p = owner_process_;
  return p != nullptr ? *p : reinterpret_cast<const ::asf::msgbus::blackbox2::protocol::Instance&>(
      ::asf::msgbus::blackbox2::protocol::_Instance_default_instance_);
}
inline const ::asf::msgbus::blackbox2::protocol::Instance& Executor::owner_process() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Executor.owner_process)
  return _internal_owner_process();
}
inline void Executor::unsafe_arena_set_allocated_owner_process(
    ::asf::msgbus::blackbox2::protocol::Instance* owner_process) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_process_);
  }
  owner_process_ = owner_process;
  if (owner_process) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:asf.msgbus.blackbox2.protocol.Executor.owner_process)
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Executor::release_owner_process() {
  
  ::asf::msgbus::blackbox2::protocol::Instance* temp = owner_process_;
  owner_process_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Executor::unsafe_arena_release_owner_process() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Executor.owner_process)
  
  ::asf::msgbus::blackbox2::protocol::Instance* temp = owner_process_;
  owner_process_ = nullptr;
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Executor::_internal_mutable_owner_process() {
  
  if (owner_process_ == nullptr) {
    auto* p = CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Instance>(GetArenaForAllocation());
    owner_process_ = p;
  }
  return owner_process_;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Executor::mutable_owner_process() {
  ::asf::msgbus::blackbox2::protocol::Instance* _msg = _internal_mutable_owner_process();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Executor.owner_process)
  return _msg;
}
inline void Executor::set_allocated_owner_process(::asf::msgbus::blackbox2::protocol::Instance* owner_process) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete owner_process_;
  }
  if (owner_process) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::asf::msgbus::blackbox2::protocol::Instance>::GetOwningArena(owner_process);
    if (message_arena != submessage_arena) {
      owner_process = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_process, submessage_arena);
    }
    
  } else {
    
  }
  owner_process_ = owner_process;
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Executor.owner_process)
}

// .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
inline bool Executor::_internal_has_owner_thread() const {
  return this != internal_default_instance() && owner_thread_ != nullptr;
}
inline bool Executor::has_owner_thread() const {
  return _internal_has_owner_thread();
}
inline void Executor::clear_owner_thread() {
  if (GetArenaForAllocation() == nullptr && owner_thread_ != nullptr) {
    delete owner_thread_;
  }
  owner_thread_ = nullptr;
}
inline const ::asf::msgbus::blackbox2::protocol::Thread& Executor::_internal_owner_thread() const {
  const ::asf::msgbus::blackbox2::protocol::Thread* p = owner_thread_;
  return p != nullptr ? *p : reinterpret_cast<const ::asf::msgbus::blackbox2::protocol::Thread&>(
      ::asf::msgbus::blackbox2::protocol::_Thread_default_instance_);
}
inline const ::asf::msgbus::blackbox2::protocol::Thread& Executor::owner_thread() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Executor.owner_thread)
  return _internal_owner_thread();
}
inline void Executor::unsafe_arena_set_allocated_owner_thread(
    ::asf::msgbus::blackbox2::protocol::Thread* owner_thread) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_thread_);
  }
  owner_thread_ = owner_thread;
  if (owner_thread) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:asf.msgbus.blackbox2.protocol.Executor.owner_thread)
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Executor::release_owner_thread() {
  
  ::asf::msgbus::blackbox2::protocol::Thread* temp = owner_thread_;
  owner_thread_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Executor::unsafe_arena_release_owner_thread() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Executor.owner_thread)
  
  ::asf::msgbus::blackbox2::protocol::Thread* temp = owner_thread_;
  owner_thread_ = nullptr;
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Executor::_internal_mutable_owner_thread() {
  
  if (owner_thread_ == nullptr) {
    auto* p = CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Thread>(GetArenaForAllocation());
    owner_thread_ = p;
  }
  return owner_thread_;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Executor::mutable_owner_thread() {
  ::asf::msgbus::blackbox2::protocol::Thread* _msg = _internal_mutable_owner_thread();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Executor.owner_thread)
  return _msg;
}
inline void Executor::set_allocated_owner_thread(::asf::msgbus::blackbox2::protocol::Thread* owner_thread) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete owner_thread_;
  }
  if (owner_thread) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::asf::msgbus::blackbox2::protocol::Thread>::GetOwningArena(owner_thread);
    if (message_arena != submessage_arena) {
      owner_thread = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_thread, submessage_arena);
    }
    
  } else {
    
  }
  owner_thread_ = owner_thread;
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Executor.owner_thread)
}

// uint32 create_thread_id = 3;
inline void Executor::clear_create_thread_id() {
  create_thread_id_ = 0u;
}
inline uint32_t Executor::_internal_create_thread_id() const {
  return create_thread_id_;
}
inline uint32_t Executor::create_thread_id() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Executor.create_thread_id)
  return _internal_create_thread_id();
}
inline void Executor::_internal_set_create_thread_id(uint32_t value) {
  
  create_thread_id_ = value;
}
inline void Executor::set_create_thread_id(uint32_t value) {
  _internal_set_create_thread_id(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Executor.create_thread_id)
}

// uint32 thread_pool_size = 4;
inline void Executor::clear_thread_pool_size() {
  thread_pool_size_ = 0u;
}
inline uint32_t Executor::_internal_thread_pool_size() const {
  return thread_pool_size_;
}
inline uint32_t Executor::thread_pool_size() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Executor.thread_pool_size)
  return _internal_thread_pool_size();
}
inline void Executor::_internal_set_thread_pool_size(uint32_t value) {
  
  thread_pool_size_ = value;
}
inline void Executor::set_thread_pool_size(uint32_t value) {
  _internal_set_thread_pool_size(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Executor.thread_pool_size)
}

// bool is_runnning = 5;
inline void Executor::clear_is_runnning() {
  is_runnning_ = false;
}
inline bool Executor::_internal_is_runnning() const {
  return is_runnning_;
}
inline bool Executor::is_runnning() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Executor.is_runnning)
  return _internal_is_runnning();
}
inline void Executor::_internal_set_is_runnning(bool value) {
  
  is_runnning_ = value;
}
inline void Executor::set_is_runnning(bool value) {
  _internal_set_is_runnning(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Executor.is_runnning)
}

// repeated string attached_nodes = 6;
inline int Executor::_internal_attached_nodes_size() const {
  return attached_nodes_.size();
}
inline int Executor::attached_nodes_size() const {
  return _internal_attached_nodes_size();
}
inline void Executor::clear_attached_nodes() {
  attached_nodes_.Clear();
}
inline std::string* Executor::add_attached_nodes() {
  std::string* _s = _internal_add_attached_nodes();
  // @@protoc_insertion_point(field_add_mutable:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
  return _s;
}
inline const std::string& Executor::_internal_attached_nodes(int index) const {
  return attached_nodes_.Get(index);
}
inline const std::string& Executor::attached_nodes(int index) const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
  return _internal_attached_nodes(index);
}
inline std::string* Executor::mutable_attached_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
  return attached_nodes_.Mutable(index);
}
inline void Executor::set_attached_nodes(int index, const std::string& value) {
  attached_nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
}
inline void Executor::set_attached_nodes(int index, std::string&& value) {
  attached_nodes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
}
inline void Executor::set_attached_nodes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  attached_nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
}
inline void Executor::set_attached_nodes(int index, const char* value, size_t size) {
  attached_nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
}
inline std::string* Executor::_internal_add_attached_nodes() {
  return attached_nodes_.Add();
}
inline void Executor::add_attached_nodes(const std::string& value) {
  attached_nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
}
inline void Executor::add_attached_nodes(std::string&& value) {
  attached_nodes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
}
inline void Executor::add_attached_nodes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  attached_nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
}
inline void Executor::add_attached_nodes(const char* value, size_t size) {
  attached_nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Executor::attached_nodes() const {
  // @@protoc_insertion_point(field_list:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
  return attached_nodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Executor::mutable_attached_nodes() {
  // @@protoc_insertion_point(field_mutable_list:asf.msgbus.blackbox2.protocol.Executor.attached_nodes)
  return &attached_nodes_;
}

// -------------------------------------------------------------------

// ExecutorTask

// .asf.msgbus.blackbox2.protocol.Thread thread = 1;
inline bool ExecutorTask::_internal_has_thread() const {
  return this != internal_default_instance() && thread_ != nullptr;
}
inline bool ExecutorTask::has_thread() const {
  return _internal_has_thread();
}
inline void ExecutorTask::clear_thread() {
  if (GetArenaForAllocation() == nullptr && thread_ != nullptr) {
    delete thread_;
  }
  thread_ = nullptr;
}
inline const ::asf::msgbus::blackbox2::protocol::Thread& ExecutorTask::_internal_thread() const {
  const ::asf::msgbus::blackbox2::protocol::Thread* p = thread_;
  return p != nullptr ? *p : reinterpret_cast<const ::asf::msgbus::blackbox2::protocol::Thread&>(
      ::asf::msgbus::blackbox2::protocol::_Thread_default_instance_);
}
inline const ::asf::msgbus::blackbox2::protocol::Thread& ExecutorTask::thread() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.ExecutorTask.thread)
  return _internal_thread();
}
inline void ExecutorTask::unsafe_arena_set_allocated_thread(
    ::asf::msgbus::blackbox2::protocol::Thread* thread) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(thread_);
  }
  thread_ = thread;
  if (thread) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:asf.msgbus.blackbox2.protocol.ExecutorTask.thread)
}
inline ::asf::msgbus::blackbox2::protocol::Thread* ExecutorTask::release_thread() {
  
  ::asf::msgbus::blackbox2::protocol::Thread* temp = thread_;
  thread_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* ExecutorTask::unsafe_arena_release_thread() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.ExecutorTask.thread)
  
  ::asf::msgbus::blackbox2::protocol::Thread* temp = thread_;
  thread_ = nullptr;
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* ExecutorTask::_internal_mutable_thread() {
  
  if (thread_ == nullptr) {
    auto* p = CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Thread>(GetArenaForAllocation());
    thread_ = p;
  }
  return thread_;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* ExecutorTask::mutable_thread() {
  ::asf::msgbus::blackbox2::protocol::Thread* _msg = _internal_mutable_thread();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.ExecutorTask.thread)
  return _msg;
}
inline void ExecutorTask::set_allocated_thread(::asf::msgbus::blackbox2::protocol::Thread* thread) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete thread_;
  }
  if (thread) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::asf::msgbus::blackbox2::protocol::Thread>::GetOwningArena(thread);
    if (message_arena != submessage_arena) {
      thread = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thread, submessage_arena);
    }
    
  } else {
    
  }
  thread_ = thread;
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.ExecutorTask.thread)
}

// uint32 task_id = 2;
inline void ExecutorTask::clear_task_id() {
  task_id_ = 0u;
}
inline uint32_t ExecutorTask::_internal_task_id() const {
  return task_id_;
}
inline uint32_t ExecutorTask::task_id() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.ExecutorTask.task_id)
  return _internal_task_id();
}
inline void ExecutorTask::_internal_set_task_id(uint32_t value) {
  
  task_id_ = value;
}
inline void ExecutorTask::set_task_id(uint32_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.ExecutorTask.task_id)
}

// -------------------------------------------------------------------

// Node

// .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
inline bool Node::_internal_has_owner_process() const {
  return this != internal_default_instance() && owner_process_ != nullptr;
}
inline bool Node::has_owner_process() const {
  return _internal_has_owner_process();
}
inline void Node::clear_owner_process() {
  if (GetArenaForAllocation() == nullptr && owner_process_ != nullptr) {
    delete owner_process_;
  }
  owner_process_ = nullptr;
}
inline const ::asf::msgbus::blackbox2::protocol::Instance& Node::_internal_owner_process() const {
  const ::asf::msgbus::blackbox2::protocol::Instance* p = owner_process_;
  return p != nullptr ? *p : reinterpret_cast<const ::asf::msgbus::blackbox2::protocol::Instance&>(
      ::asf::msgbus::blackbox2::protocol::_Instance_default_instance_);
}
inline const ::asf::msgbus::blackbox2::protocol::Instance& Node::owner_process() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Node.owner_process)
  return _internal_owner_process();
}
inline void Node::unsafe_arena_set_allocated_owner_process(
    ::asf::msgbus::blackbox2::protocol::Instance* owner_process) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_process_);
  }
  owner_process_ = owner_process;
  if (owner_process) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:asf.msgbus.blackbox2.protocol.Node.owner_process)
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Node::release_owner_process() {
  
  ::asf::msgbus::blackbox2::protocol::Instance* temp = owner_process_;
  owner_process_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Node::unsafe_arena_release_owner_process() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Node.owner_process)
  
  ::asf::msgbus::blackbox2::protocol::Instance* temp = owner_process_;
  owner_process_ = nullptr;
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Node::_internal_mutable_owner_process() {
  
  if (owner_process_ == nullptr) {
    auto* p = CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Instance>(GetArenaForAllocation());
    owner_process_ = p;
  }
  return owner_process_;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Node::mutable_owner_process() {
  ::asf::msgbus::blackbox2::protocol::Instance* _msg = _internal_mutable_owner_process();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Node.owner_process)
  return _msg;
}
inline void Node::set_allocated_owner_process(::asf::msgbus::blackbox2::protocol::Instance* owner_process) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete owner_process_;
  }
  if (owner_process) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::asf::msgbus::blackbox2::protocol::Instance>::GetOwningArena(owner_process);
    if (message_arena != submessage_arena) {
      owner_process = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_process, submessage_arena);
    }
    
  } else {
    
  }
  owner_process_ = owner_process;
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Node.owner_process)
}

// .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
inline bool Node::_internal_has_owner_thread() const {
  return this != internal_default_instance() && owner_thread_ != nullptr;
}
inline bool Node::has_owner_thread() const {
  return _internal_has_owner_thread();
}
inline void Node::clear_owner_thread() {
  if (GetArenaForAllocation() == nullptr && owner_thread_ != nullptr) {
    delete owner_thread_;
  }
  owner_thread_ = nullptr;
}
inline const ::asf::msgbus::blackbox2::protocol::Thread& Node::_internal_owner_thread() const {
  const ::asf::msgbus::blackbox2::protocol::Thread* p = owner_thread_;
  return p != nullptr ? *p : reinterpret_cast<const ::asf::msgbus::blackbox2::protocol::Thread&>(
      ::asf::msgbus::blackbox2::protocol::_Thread_default_instance_);
}
inline const ::asf::msgbus::blackbox2::protocol::Thread& Node::owner_thread() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Node.owner_thread)
  return _internal_owner_thread();
}
inline void Node::unsafe_arena_set_allocated_owner_thread(
    ::asf::msgbus::blackbox2::protocol::Thread* owner_thread) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_thread_);
  }
  owner_thread_ = owner_thread;
  if (owner_thread) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:asf.msgbus.blackbox2.protocol.Node.owner_thread)
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Node::release_owner_thread() {
  
  ::asf::msgbus::blackbox2::protocol::Thread* temp = owner_thread_;
  owner_thread_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Node::unsafe_arena_release_owner_thread() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Node.owner_thread)
  
  ::asf::msgbus::blackbox2::protocol::Thread* temp = owner_thread_;
  owner_thread_ = nullptr;
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Node::_internal_mutable_owner_thread() {
  
  if (owner_thread_ == nullptr) {
    auto* p = CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Thread>(GetArenaForAllocation());
    owner_thread_ = p;
  }
  return owner_thread_;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Node::mutable_owner_thread() {
  ::asf::msgbus::blackbox2::protocol::Thread* _msg = _internal_mutable_owner_thread();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Node.owner_thread)
  return _msg;
}
inline void Node::set_allocated_owner_thread(::asf::msgbus::blackbox2::protocol::Thread* owner_thread) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete owner_thread_;
  }
  if (owner_thread) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::asf::msgbus::blackbox2::protocol::Thread>::GetOwningArena(owner_thread);
    if (message_arena != submessage_arena) {
      owner_thread = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_thread, submessage_arena);
    }
    
  } else {
    
  }
  owner_thread_ = owner_thread;
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Node.owner_thread)
}

// string name = 3;
inline void Node::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Node.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Node.name)
}
inline std::string* Node::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Node.name)
  return _s;
}
inline const std::string& Node::_internal_name() const {
  return name_.Get();
}
inline void Node::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Node.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Node::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Node.name)
}

// bool is_attached = 4;
inline void Node::clear_is_attached() {
  is_attached_ = false;
}
inline bool Node::_internal_is_attached() const {
  return is_attached_;
}
inline bool Node::is_attached() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Node.is_attached)
  return _internal_is_attached();
}
inline void Node::_internal_set_is_attached(bool value) {
  
  is_attached_ = value;
}
inline void Node::set_is_attached(bool value) {
  _internal_set_is_attached(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Node.is_attached)
}

// -------------------------------------------------------------------

// KeyStat

// bool valid = 1;
inline void KeyStat::clear_valid() {
  valid_ = false;
}
inline bool KeyStat::_internal_valid() const {
  return valid_;
}
inline bool KeyStat::valid() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.valid)
  return _internal_valid();
}
inline void KeyStat::_internal_set_valid(bool value) {
  
  valid_ = value;
}
inline void KeyStat::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.valid)
}

// uint64 rx_subscriber = 2;
inline void KeyStat::clear_rx_subscriber() {
  rx_subscriber_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_rx_subscriber() const {
  return rx_subscriber_;
}
inline uint64_t KeyStat::rx_subscriber() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.rx_subscriber)
  return _internal_rx_subscriber();
}
inline void KeyStat::_internal_set_rx_subscriber(uint64_t value) {
  
  rx_subscriber_ = value;
}
inline void KeyStat::set_rx_subscriber(uint64_t value) {
  _internal_set_rx_subscriber(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.rx_subscriber)
}

// uint64 rx_unsubscriber = 3;
inline void KeyStat::clear_rx_unsubscriber() {
  rx_unsubscriber_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_rx_unsubscriber() const {
  return rx_unsubscriber_;
}
inline uint64_t KeyStat::rx_unsubscriber() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.rx_unsubscriber)
  return _internal_rx_unsubscriber();
}
inline void KeyStat::_internal_set_rx_unsubscriber(uint64_t value) {
  
  rx_unsubscriber_ = value;
}
inline void KeyStat::set_rx_unsubscriber(uint64_t value) {
  _internal_set_rx_unsubscriber(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.rx_unsubscriber)
}

// uint64 rx_packets = 4;
inline void KeyStat::clear_rx_packets() {
  rx_packets_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_rx_packets() const {
  return rx_packets_;
}
inline uint64_t KeyStat::rx_packets() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.rx_packets)
  return _internal_rx_packets();
}
inline void KeyStat::_internal_set_rx_packets(uint64_t value) {
  
  rx_packets_ = value;
}
inline void KeyStat::set_rx_packets(uint64_t value) {
  _internal_set_rx_packets(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.rx_packets)
}

// uint64 rx_bytes = 5;
inline void KeyStat::clear_rx_bytes() {
  rx_bytes_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_rx_bytes() const {
  return rx_bytes_;
}
inline uint64_t KeyStat::rx_bytes() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.rx_bytes)
  return _internal_rx_bytes();
}
inline void KeyStat::_internal_set_rx_bytes(uint64_t value) {
  
  rx_bytes_ = value;
}
inline void KeyStat::set_rx_bytes(uint64_t value) {
  _internal_set_rx_bytes(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.rx_bytes)
}

// uint64 rx_multicast = 6;
inline void KeyStat::clear_rx_multicast() {
  rx_multicast_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_rx_multicast() const {
  return rx_multicast_;
}
inline uint64_t KeyStat::rx_multicast() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.rx_multicast)
  return _internal_rx_multicast();
}
inline void KeyStat::_internal_set_rx_multicast(uint64_t value) {
  
  rx_multicast_ = value;
}
inline void KeyStat::set_rx_multicast(uint64_t value) {
  _internal_set_rx_multicast(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.rx_multicast)
}

// uint64 rx_length_errors = 7;
inline void KeyStat::clear_rx_length_errors() {
  rx_length_errors_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_rx_length_errors() const {
  return rx_length_errors_;
}
inline uint64_t KeyStat::rx_length_errors() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.rx_length_errors)
  return _internal_rx_length_errors();
}
inline void KeyStat::_internal_set_rx_length_errors(uint64_t value) {
  
  rx_length_errors_ = value;
}
inline void KeyStat::set_rx_length_errors(uint64_t value) {
  _internal_set_rx_length_errors(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.rx_length_errors)
}

// uint64 rx_no_buffer = 8;
inline void KeyStat::clear_rx_no_buffer() {
  rx_no_buffer_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_rx_no_buffer() const {
  return rx_no_buffer_;
}
inline uint64_t KeyStat::rx_no_buffer() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.rx_no_buffer)
  return _internal_rx_no_buffer();
}
inline void KeyStat::_internal_set_rx_no_buffer(uint64_t value) {
  
  rx_no_buffer_ = value;
}
inline void KeyStat::set_rx_no_buffer(uint64_t value) {
  _internal_set_rx_no_buffer(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.rx_no_buffer)
}

// uint64 rx_no_reader = 9;
inline void KeyStat::clear_rx_no_reader() {
  rx_no_reader_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_rx_no_reader() const {
  return rx_no_reader_;
}
inline uint64_t KeyStat::rx_no_reader() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.rx_no_reader)
  return _internal_rx_no_reader();
}
inline void KeyStat::_internal_set_rx_no_reader(uint64_t value) {
  
  rx_no_reader_ = value;
}
inline void KeyStat::set_rx_no_reader(uint64_t value) {
  _internal_set_rx_no_reader(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.rx_no_reader)
}

// uint64 tx_subscriber = 10;
inline void KeyStat::clear_tx_subscriber() {
  tx_subscriber_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_tx_subscriber() const {
  return tx_subscriber_;
}
inline uint64_t KeyStat::tx_subscriber() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.tx_subscriber)
  return _internal_tx_subscriber();
}
inline void KeyStat::_internal_set_tx_subscriber(uint64_t value) {
  
  tx_subscriber_ = value;
}
inline void KeyStat::set_tx_subscriber(uint64_t value) {
  _internal_set_tx_subscriber(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.tx_subscriber)
}

// uint64 tx_unsubscriber = 11;
inline void KeyStat::clear_tx_unsubscriber() {
  tx_unsubscriber_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_tx_unsubscriber() const {
  return tx_unsubscriber_;
}
inline uint64_t KeyStat::tx_unsubscriber() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.tx_unsubscriber)
  return _internal_tx_unsubscriber();
}
inline void KeyStat::_internal_set_tx_unsubscriber(uint64_t value) {
  
  tx_unsubscriber_ = value;
}
inline void KeyStat::set_tx_unsubscriber(uint64_t value) {
  _internal_set_tx_unsubscriber(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.tx_unsubscriber)
}

// uint64 tx_packets = 12;
inline void KeyStat::clear_tx_packets() {
  tx_packets_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_tx_packets() const {
  return tx_packets_;
}
inline uint64_t KeyStat::tx_packets() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.tx_packets)
  return _internal_tx_packets();
}
inline void KeyStat::_internal_set_tx_packets(uint64_t value) {
  
  tx_packets_ = value;
}
inline void KeyStat::set_tx_packets(uint64_t value) {
  _internal_set_tx_packets(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.tx_packets)
}

// uint64 tx_bytes = 13;
inline void KeyStat::clear_tx_bytes() {
  tx_bytes_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_tx_bytes() const {
  return tx_bytes_;
}
inline uint64_t KeyStat::tx_bytes() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.tx_bytes)
  return _internal_tx_bytes();
}
inline void KeyStat::_internal_set_tx_bytes(uint64_t value) {
  
  tx_bytes_ = value;
}
inline void KeyStat::set_tx_bytes(uint64_t value) {
  _internal_set_tx_bytes(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.tx_bytes)
}

// uint64 tx_multicast = 14;
inline void KeyStat::clear_tx_multicast() {
  tx_multicast_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_tx_multicast() const {
  return tx_multicast_;
}
inline uint64_t KeyStat::tx_multicast() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.tx_multicast)
  return _internal_tx_multicast();
}
inline void KeyStat::_internal_set_tx_multicast(uint64_t value) {
  
  tx_multicast_ = value;
}
inline void KeyStat::set_tx_multicast(uint64_t value) {
  _internal_set_tx_multicast(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.tx_multicast)
}

// uint64 tx_no_transmit = 15;
inline void KeyStat::clear_tx_no_transmit() {
  tx_no_transmit_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_tx_no_transmit() const {
  return tx_no_transmit_;
}
inline uint64_t KeyStat::tx_no_transmit() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.tx_no_transmit)
  return _internal_tx_no_transmit();
}
inline void KeyStat::_internal_set_tx_no_transmit(uint64_t value) {
  
  tx_no_transmit_ = value;
}
inline void KeyStat::set_tx_no_transmit(uint64_t value) {
  _internal_set_tx_no_transmit(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.tx_no_transmit)
}

// uint64 tx_length_errors = 16;
inline void KeyStat::clear_tx_length_errors() {
  tx_length_errors_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_tx_length_errors() const {
  return tx_length_errors_;
}
inline uint64_t KeyStat::tx_length_errors() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.tx_length_errors)
  return _internal_tx_length_errors();
}
inline void KeyStat::_internal_set_tx_length_errors(uint64_t value) {
  
  tx_length_errors_ = value;
}
inline void KeyStat::set_tx_length_errors(uint64_t value) {
  _internal_set_tx_length_errors(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.tx_length_errors)
}

// uint64 tx_no_channel = 17;
inline void KeyStat::clear_tx_no_channel() {
  tx_no_channel_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_tx_no_channel() const {
  return tx_no_channel_;
}
inline uint64_t KeyStat::tx_no_channel() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.tx_no_channel)
  return _internal_tx_no_channel();
}
inline void KeyStat::_internal_set_tx_no_channel(uint64_t value) {
  
  tx_no_channel_ = value;
}
inline void KeyStat::set_tx_no_channel(uint64_t value) {
  _internal_set_tx_no_channel(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.tx_no_channel)
}

// uint64 tx_no_subscriber = 18;
inline void KeyStat::clear_tx_no_subscriber() {
  tx_no_subscriber_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_tx_no_subscriber() const {
  return tx_no_subscriber_;
}
inline uint64_t KeyStat::tx_no_subscriber() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.tx_no_subscriber)
  return _internal_tx_no_subscriber();
}
inline void KeyStat::_internal_set_tx_no_subscriber(uint64_t value) {
  
  tx_no_subscriber_ = value;
}
inline void KeyStat::set_tx_no_subscriber(uint64_t value) {
  _internal_set_tx_no_subscriber(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.tx_no_subscriber)
}

// uint64 tx_no_endpoint = 19;
inline void KeyStat::clear_tx_no_endpoint() {
  tx_no_endpoint_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_tx_no_endpoint() const {
  return tx_no_endpoint_;
}
inline uint64_t KeyStat::tx_no_endpoint() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.tx_no_endpoint)
  return _internal_tx_no_endpoint();
}
inline void KeyStat::_internal_set_tx_no_endpoint(uint64_t value) {
  
  tx_no_endpoint_ = value;
}
inline void KeyStat::set_tx_no_endpoint(uint64_t value) {
  _internal_set_tx_no_endpoint(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.tx_no_endpoint)
}

// uint64 tx_no_buffer = 20;
inline void KeyStat::clear_tx_no_buffer() {
  tx_no_buffer_ = uint64_t{0u};
}
inline uint64_t KeyStat::_internal_tx_no_buffer() const {
  return tx_no_buffer_;
}
inline uint64_t KeyStat::tx_no_buffer() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.KeyStat.tx_no_buffer)
  return _internal_tx_no_buffer();
}
inline void KeyStat::_internal_set_tx_no_buffer(uint64_t value) {
  
  tx_no_buffer_ = value;
}
inline void KeyStat::set_tx_no_buffer(uint64_t value) {
  _internal_set_tx_no_buffer(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.KeyStat.tx_no_buffer)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Handle

// .asf.msgbus.blackbox2.protocol.Instance owner_node = 1;
inline bool Handle::_internal_has_owner_node() const {
  return this != internal_default_instance() && owner_node_ != nullptr;
}
inline bool Handle::has_owner_node() const {
  return _internal_has_owner_node();
}
inline void Handle::clear_owner_node() {
  if (GetArenaForAllocation() == nullptr && owner_node_ != nullptr) {
    delete owner_node_;
  }
  owner_node_ = nullptr;
}
inline const ::asf::msgbus::blackbox2::protocol::Instance& Handle::_internal_owner_node() const {
  const ::asf::msgbus::blackbox2::protocol::Instance* p = owner_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::asf::msgbus::blackbox2::protocol::Instance&>(
      ::asf::msgbus::blackbox2::protocol::_Instance_default_instance_);
}
inline const ::asf::msgbus::blackbox2::protocol::Instance& Handle::owner_node() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Handle.owner_node)
  return _internal_owner_node();
}
inline void Handle::unsafe_arena_set_allocated_owner_node(
    ::asf::msgbus::blackbox2::protocol::Instance* owner_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_node_);
  }
  owner_node_ = owner_node;
  if (owner_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:asf.msgbus.blackbox2.protocol.Handle.owner_node)
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Handle::release_owner_node() {
  
  ::asf::msgbus::blackbox2::protocol::Instance* temp = owner_node_;
  owner_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Handle::unsafe_arena_release_owner_node() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Handle.owner_node)
  
  ::asf::msgbus::blackbox2::protocol::Instance* temp = owner_node_;
  owner_node_ = nullptr;
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Handle::_internal_mutable_owner_node() {
  
  if (owner_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Instance>(GetArenaForAllocation());
    owner_node_ = p;
  }
  return owner_node_;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* Handle::mutable_owner_node() {
  ::asf::msgbus::blackbox2::protocol::Instance* _msg = _internal_mutable_owner_node();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Handle.owner_node)
  return _msg;
}
inline void Handle::set_allocated_owner_node(::asf::msgbus::blackbox2::protocol::Instance* owner_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete owner_node_;
  }
  if (owner_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::asf::msgbus::blackbox2::protocol::Instance>::GetOwningArena(owner_node);
    if (message_arena != submessage_arena) {
      owner_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_node, submessage_arena);
    }
    
  } else {
    
  }
  owner_node_ = owner_node;
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Handle.owner_node)
}

// .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
inline bool Handle::_internal_has_owner_thread() const {
  return this != internal_default_instance() && owner_thread_ != nullptr;
}
inline bool Handle::has_owner_thread() const {
  return _internal_has_owner_thread();
}
inline void Handle::clear_owner_thread() {
  if (GetArenaForAllocation() == nullptr && owner_thread_ != nullptr) {
    delete owner_thread_;
  }
  owner_thread_ = nullptr;
}
inline const ::asf::msgbus::blackbox2::protocol::Thread& Handle::_internal_owner_thread() const {
  const ::asf::msgbus::blackbox2::protocol::Thread* p = owner_thread_;
  return p != nullptr ? *p : reinterpret_cast<const ::asf::msgbus::blackbox2::protocol::Thread&>(
      ::asf::msgbus::blackbox2::protocol::_Thread_default_instance_);
}
inline const ::asf::msgbus::blackbox2::protocol::Thread& Handle::owner_thread() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Handle.owner_thread)
  return _internal_owner_thread();
}
inline void Handle::unsafe_arena_set_allocated_owner_thread(
    ::asf::msgbus::blackbox2::protocol::Thread* owner_thread) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_thread_);
  }
  owner_thread_ = owner_thread;
  if (owner_thread) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:asf.msgbus.blackbox2.protocol.Handle.owner_thread)
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Handle::release_owner_thread() {
  
  ::asf::msgbus::blackbox2::protocol::Thread* temp = owner_thread_;
  owner_thread_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Handle::unsafe_arena_release_owner_thread() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Handle.owner_thread)
  
  ::asf::msgbus::blackbox2::protocol::Thread* temp = owner_thread_;
  owner_thread_ = nullptr;
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Handle::_internal_mutable_owner_thread() {
  
  if (owner_thread_ == nullptr) {
    auto* p = CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Thread>(GetArenaForAllocation());
    owner_thread_ = p;
  }
  return owner_thread_;
}
inline ::asf::msgbus::blackbox2::protocol::Thread* Handle::mutable_owner_thread() {
  ::asf::msgbus::blackbox2::protocol::Thread* _msg = _internal_mutable_owner_thread();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Handle.owner_thread)
  return _msg;
}
inline void Handle::set_allocated_owner_thread(::asf::msgbus::blackbox2::protocol::Thread* owner_thread) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete owner_thread_;
  }
  if (owner_thread) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::asf::msgbus::blackbox2::protocol::Thread>::GetOwningArena(owner_thread);
    if (message_arena != submessage_arena) {
      owner_thread = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_thread, submessage_arena);
    }
    
  } else {
    
  }
  owner_thread_ = owner_thread;
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Handle.owner_thread)
}

// .asf.msgbus.blackbox2.protocol.HandleType type = 3;
inline void Handle::clear_type() {
  type_ = 0;
}
inline ::asf::msgbus::blackbox2::protocol::HandleType Handle::_internal_type() const {
  return static_cast< ::asf::msgbus::blackbox2::protocol::HandleType >(type_);
}
inline ::asf::msgbus::blackbox2::protocol::HandleType Handle::type() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Handle.type)
  return _internal_type();
}
inline void Handle::_internal_set_type(::asf::msgbus::blackbox2::protocol::HandleType value) {
  
  type_ = value;
}
inline void Handle::set_type(::asf::msgbus::blackbox2::protocol::HandleType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Handle.type)
}

// string key = 4;
inline void Handle::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& Handle::key() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Handle.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Handle::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Handle.key)
}
inline std::string* Handle::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Handle.key)
  return _s;
}
inline const std::string& Handle::_internal_key() const {
  return key_.Get();
}
inline void Handle::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Handle::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Handle::release_key() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Handle.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Handle::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Handle.key)
}

// bool is_enabled = 5;
inline void Handle::clear_is_enabled() {
  is_enabled_ = false;
}
inline bool Handle::_internal_is_enabled() const {
  return is_enabled_;
}
inline bool Handle::is_enabled() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Handle.is_enabled)
  return _internal_is_enabled();
}
inline void Handle::_internal_set_is_enabled(bool value) {
  
  is_enabled_ = value;
}
inline void Handle::set_is_enabled(bool value) {
  _internal_set_is_enabled(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Handle.is_enabled)
}

// map<string, string> mapping_channels = 6;
inline int Handle::_internal_mapping_channels_size() const {
  return mapping_channels_.size();
}
inline int Handle::mapping_channels_size() const {
  return _internal_mapping_channels_size();
}
inline void Handle::clear_mapping_channels() {
  mapping_channels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Handle::_internal_mapping_channels() const {
  return mapping_channels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Handle::mapping_channels() const {
  // @@protoc_insertion_point(field_map:asf.msgbus.blackbox2.protocol.Handle.mapping_channels)
  return _internal_mapping_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Handle::_internal_mutable_mapping_channels() {
  return mapping_channels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Handle::mutable_mapping_channels() {
  // @@protoc_insertion_point(field_mutable_map:asf.msgbus.blackbox2.protocol.Handle.mapping_channels)
  return _internal_mutable_mapping_channels();
}

// -------------------------------------------------------------------

// AttachResponse

// .asf.msgbus.blackbox2.protocol.Instance instance = 1;
inline bool AttachResponse::_internal_has_instance() const {
  return this != internal_default_instance() && instance_ != nullptr;
}
inline bool AttachResponse::has_instance() const {
  return _internal_has_instance();
}
inline void AttachResponse::clear_instance() {
  if (GetArenaForAllocation() == nullptr && instance_ != nullptr) {
    delete instance_;
  }
  instance_ = nullptr;
}
inline const ::asf::msgbus::blackbox2::protocol::Instance& AttachResponse::_internal_instance() const {
  const ::asf::msgbus::blackbox2::protocol::Instance* p = instance_;
  return p != nullptr ? *p : reinterpret_cast<const ::asf::msgbus::blackbox2::protocol::Instance&>(
      ::asf::msgbus::blackbox2::protocol::_Instance_default_instance_);
}
inline const ::asf::msgbus::blackbox2::protocol::Instance& AttachResponse::instance() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.AttachResponse.instance)
  return _internal_instance();
}
inline void AttachResponse::unsafe_arena_set_allocated_instance(
    ::asf::msgbus::blackbox2::protocol::Instance* instance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instance_);
  }
  instance_ = instance;
  if (instance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:asf.msgbus.blackbox2.protocol.AttachResponse.instance)
}
inline ::asf::msgbus::blackbox2::protocol::Instance* AttachResponse::release_instance() {
  
  ::asf::msgbus::blackbox2::protocol::Instance* temp = instance_;
  instance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* AttachResponse::unsafe_arena_release_instance() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.AttachResponse.instance)
  
  ::asf::msgbus::blackbox2::protocol::Instance* temp = instance_;
  instance_ = nullptr;
  return temp;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* AttachResponse::_internal_mutable_instance() {
  
  if (instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::asf::msgbus::blackbox2::protocol::Instance>(GetArenaForAllocation());
    instance_ = p;
  }
  return instance_;
}
inline ::asf::msgbus::blackbox2::protocol::Instance* AttachResponse::mutable_instance() {
  ::asf::msgbus::blackbox2::protocol::Instance* _msg = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.AttachResponse.instance)
  return _msg;
}
inline void AttachResponse::set_allocated_instance(::asf::msgbus::blackbox2::protocol::Instance* instance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete instance_;
  }
  if (instance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::asf::msgbus::blackbox2::protocol::Instance>::GetOwningArena(instance);
    if (message_arena != submessage_arena) {
      instance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    
  } else {
    
  }
  instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.AttachResponse.instance)
}

// bool is_activated = 2;
inline void AttachResponse::clear_is_activated() {
  is_activated_ = false;
}
inline bool AttachResponse::_internal_is_activated() const {
  return is_activated_;
}
inline bool AttachResponse::is_activated() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.AttachResponse.is_activated)
  return _internal_is_activated();
}
inline void AttachResponse::_internal_set_is_activated(bool value) {
  
  is_activated_ = value;
}
inline void AttachResponse::set_is_activated(bool value) {
  _internal_set_is_activated(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.AttachResponse.is_activated)
}

// -------------------------------------------------------------------

// Message

// .asf.msgbus.blackbox2.protocol.Direction dir = 1;
inline void Message::clear_dir() {
  dir_ = 0;
}
inline ::asf::msgbus::blackbox2::protocol::Direction Message::_internal_dir() const {
  return static_cast< ::asf::msgbus::blackbox2::protocol::Direction >(dir_);
}
inline ::asf::msgbus::blackbox2::protocol::Direction Message::dir() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Message.dir)
  return _internal_dir();
}
inline void Message::_internal_set_dir(::asf::msgbus::blackbox2::protocol::Direction value) {
  
  dir_ = value;
}
inline void Message::set_dir(::asf::msgbus::blackbox2::protocol::Direction value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Message.dir)
}

// optional bytes payload = 2;
inline bool Message::_internal_has_payload() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Message::has_payload() const {
  return _internal_has_payload();
}
inline void Message::clear_payload() {
  payload_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Message::payload() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Message.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_payload(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Message.payload)
}
inline std::string* Message::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Message.payload)
  return _s;
}
inline const std::string& Message::_internal_payload() const {
  return payload_.Get();
}
inline void Message::_internal_set_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_payload() {
  _has_bits_[0] |= 0x00000001u;
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Message::release_payload() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Message.payload)
  if (!_internal_has_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = payload_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Message::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Message.payload)
}

// optional bool is_pod = 3;
inline bool Message::_internal_has_is_pod() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Message::has_is_pod() const {
  return _internal_has_is_pod();
}
inline void Message::clear_is_pod() {
  is_pod_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Message::_internal_is_pod() const {
  return is_pod_;
}
inline bool Message::is_pod() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Message.is_pod)
  return _internal_is_pod();
}
inline void Message::_internal_set_is_pod(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_pod_ = value;
}
inline void Message::set_is_pod(bool value) {
  _internal_set_is_pod(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Message.is_pod)
}

// optional string serialize_type = 4;
inline bool Message::_internal_has_serialize_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Message::has_serialize_type() const {
  return _internal_has_serialize_type();
}
inline void Message::clear_serialize_type() {
  serialize_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Message::serialize_type() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Message.serialize_type)
  return _internal_serialize_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_serialize_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 serialize_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Message.serialize_type)
}
inline std::string* Message::mutable_serialize_type() {
  std::string* _s = _internal_mutable_serialize_type();
  // @@protoc_insertion_point(field_mutable:asf.msgbus.blackbox2.protocol.Message.serialize_type)
  return _s;
}
inline const std::string& Message::_internal_serialize_type() const {
  return serialize_type_.Get();
}
inline void Message::_internal_set_serialize_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  serialize_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_serialize_type() {
  _has_bits_[0] |= 0x00000002u;
  return serialize_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Message::release_serialize_type() {
  // @@protoc_insertion_point(field_release:asf.msgbus.blackbox2.protocol.Message.serialize_type)
  if (!_internal_has_serialize_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = serialize_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialize_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serialize_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Message::set_allocated_serialize_type(std::string* serialize_type) {
  if (serialize_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  serialize_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialize_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialize_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serialize_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:asf.msgbus.blackbox2.protocol.Message.serialize_type)
}

// optional uint64 gen_timestamp = 5;
inline bool Message::_internal_has_gen_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Message::has_gen_timestamp() const {
  return _internal_has_gen_timestamp();
}
inline void Message::clear_gen_timestamp() {
  gen_timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t Message::_internal_gen_timestamp() const {
  return gen_timestamp_;
}
inline uint64_t Message::gen_timestamp() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Message.gen_timestamp)
  return _internal_gen_timestamp();
}
inline void Message::_internal_set_gen_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  gen_timestamp_ = value;
}
inline void Message::set_gen_timestamp(uint64_t value) {
  _internal_set_gen_timestamp(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Message.gen_timestamp)
}

// optional uint64 tx_timestamp = 6;
inline bool Message::_internal_has_tx_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Message::has_tx_timestamp() const {
  return _internal_has_tx_timestamp();
}
inline void Message::clear_tx_timestamp() {
  tx_timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t Message::_internal_tx_timestamp() const {
  return tx_timestamp_;
}
inline uint64_t Message::tx_timestamp() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Message.tx_timestamp)
  return _internal_tx_timestamp();
}
inline void Message::_internal_set_tx_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  tx_timestamp_ = value;
}
inline void Message::set_tx_timestamp(uint64_t value) {
  _internal_set_tx_timestamp(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Message.tx_timestamp)
}

// optional uint64 rx_timestamp = 7;
inline bool Message::_internal_has_rx_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Message::has_rx_timestamp() const {
  return _internal_has_rx_timestamp();
}
inline void Message::clear_rx_timestamp() {
  rx_timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t Message::_internal_rx_timestamp() const {
  return rx_timestamp_;
}
inline uint64_t Message::rx_timestamp() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Message.rx_timestamp)
  return _internal_rx_timestamp();
}
inline void Message::_internal_set_rx_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  rx_timestamp_ = value;
}
inline void Message::set_rx_timestamp(uint64_t value) {
  _internal_set_rx_timestamp(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Message.rx_timestamp)
}

// optional uint64 write_timestamp = 8;
inline bool Message::_internal_has_write_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Message::has_write_timestamp() const {
  return _internal_has_write_timestamp();
}
inline void Message::clear_write_timestamp() {
  write_timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t Message::_internal_write_timestamp() const {
  return write_timestamp_;
}
inline uint64_t Message::write_timestamp() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Message.write_timestamp)
  return _internal_write_timestamp();
}
inline void Message::_internal_set_write_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  write_timestamp_ = value;
}
inline void Message::set_write_timestamp(uint64_t value) {
  _internal_set_write_timestamp(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Message.write_timestamp)
}

// optional uint64 read_timestamp = 9;
inline bool Message::_internal_has_read_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Message::has_read_timestamp() const {
  return _internal_has_read_timestamp();
}
inline void Message::clear_read_timestamp() {
  read_timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline uint64_t Message::_internal_read_timestamp() const {
  return read_timestamp_;
}
inline uint64_t Message::read_timestamp() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.Message.read_timestamp)
  return _internal_read_timestamp();
}
inline void Message::_internal_set_read_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000080u;
  read_timestamp_ = value;
}
inline void Message::set_read_timestamp(uint64_t value) {
  _internal_set_read_timestamp(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.Message.read_timestamp)
}

// -------------------------------------------------------------------

// MessageFields

// uint32 has_flags = 1;
inline void MessageFields::clear_has_flags() {
  has_flags_ = 0u;
}
inline uint32_t MessageFields::_internal_has_flags() const {
  return has_flags_;
}
inline uint32_t MessageFields::has_flags() const {
  // @@protoc_insertion_point(field_get:asf.msgbus.blackbox2.protocol.MessageFields.has_flags)
  return _internal_has_flags();
}
inline void MessageFields::_internal_set_has_flags(uint32_t value) {
  
  has_flags_ = value;
}
inline void MessageFields::set_has_flags(uint32_t value) {
  _internal_set_has_flags(value);
  // @@protoc_insertion_point(field_set:asf.msgbus.blackbox2.protocol.MessageFields.has_flags)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace blackbox2
}  // namespace msgbus
}  // namespace asf

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::asf::msgbus::blackbox2::protocol::Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::asf::msgbus::blackbox2::protocol::Direction>() {
  return ::asf::msgbus::blackbox2::protocol::Direction_descriptor();
}
template <> struct is_proto_enum< ::asf::msgbus::blackbox2::protocol::HandleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::asf::msgbus::blackbox2::protocol::HandleType>() {
  return ::asf::msgbus::blackbox2::protocol::HandleType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protocol_5fmessage_2eproto
