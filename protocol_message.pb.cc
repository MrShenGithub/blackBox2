// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol_message.proto

#include "protocol_message.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace asf {
namespace msgbus {
namespace blackbox2 {
namespace protocol {
constexpr Boolean::Boolean(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : value_(false){}
struct BooleanDefaultTypeInternal {
  constexpr BooleanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BooleanDefaultTypeInternal() {}
  union {
    Boolean _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BooleanDefaultTypeInternal _Boolean_default_instance_;
constexpr String::String(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct StringDefaultTypeInternal {
  constexpr StringDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StringDefaultTypeInternal() {}
  union {
    String _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StringDefaultTypeInternal _String_default_instance_;
constexpr Instance::Instance(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(uint64_t{0u}){}
struct InstanceDefaultTypeInternal {
  constexpr InstanceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InstanceDefaultTypeInternal() {}
  union {
    Instance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InstanceDefaultTypeInternal _Instance_default_instance_;
constexpr Result::Result(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : code_(0u){}
struct ResultDefaultTypeInternal {
  constexpr ResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ResultDefaultTypeInternal() {}
  union {
    Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ResultDefaultTypeInternal _Result_default_instance_;
constexpr Version::Version(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : major_number_(0u)
  , minor_number_(0u)
  , patch_number_(0u){}
struct VersionDefaultTypeInternal {
  constexpr VersionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VersionDefaultTypeInternal() {}
  union {
    Version _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VersionDefaultTypeInternal _Version_default_instance_;
constexpr Thread::Thread(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(uint64_t{0u}){}
struct ThreadDefaultTypeInternal {
  constexpr ThreadDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ThreadDefaultTypeInternal() {}
  union {
    Thread _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ThreadDefaultTypeInternal _Thread_default_instance_;
constexpr Process::Process(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cmdline_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , workding_directory_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , environments_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , config_filename_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , version_(nullptr)
  , startup_timestamp_(uint64_t{0u})
  , pid_(0u){}
struct ProcessDefaultTypeInternal {
  constexpr ProcessDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ProcessDefaultTypeInternal() {}
  union {
    Process _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ProcessDefaultTypeInternal _Process_default_instance_;
constexpr Channel_ConfigEntry_DoNotUse::Channel_ConfigEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Channel_ConfigEntry_DoNotUseDefaultTypeInternal {
  constexpr Channel_ConfigEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Channel_ConfigEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Channel_ConfigEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Channel_ConfigEntry_DoNotUseDefaultTypeInternal _Channel_ConfigEntry_DoNotUse_default_instance_;
constexpr Channel::Channel(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : config_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , owner_process_(nullptr)
  , owner_thread_(nullptr)
  , dir_(0)
{}
struct ChannelDefaultTypeInternal {
  constexpr ChannelDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ChannelDefaultTypeInternal() {}
  union {
    Channel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ChannelDefaultTypeInternal _Channel_default_instance_;
constexpr Executor::Executor(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : attached_nodes_()
  , owner_process_(nullptr)
  , owner_thread_(nullptr)
  , create_thread_id_(0u)
  , thread_pool_size_(0u)
  , is_runnning_(false){}
struct ExecutorDefaultTypeInternal {
  constexpr ExecutorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ExecutorDefaultTypeInternal() {}
  union {
    Executor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ExecutorDefaultTypeInternal _Executor_default_instance_;
constexpr ExecutorTask::ExecutorTask(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : thread_(nullptr)
  , task_id_(0u){}
struct ExecutorTaskDefaultTypeInternal {
  constexpr ExecutorTaskDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ExecutorTaskDefaultTypeInternal() {}
  union {
    ExecutorTask _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ExecutorTaskDefaultTypeInternal _ExecutorTask_default_instance_;
constexpr Node::Node(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , owner_process_(nullptr)
  , owner_thread_(nullptr)
  , is_attached_(false){}
struct NodeDefaultTypeInternal {
  constexpr NodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NodeDefaultTypeInternal() {}
  union {
    Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NodeDefaultTypeInternal _Node_default_instance_;
constexpr KeyStat::KeyStat(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : rx_subscriber_(uint64_t{0u})
  , rx_unsubscriber_(uint64_t{0u})
  , rx_packets_(uint64_t{0u})
  , rx_bytes_(uint64_t{0u})
  , rx_multicast_(uint64_t{0u})
  , rx_length_errors_(uint64_t{0u})
  , rx_no_buffer_(uint64_t{0u})
  , rx_no_reader_(uint64_t{0u})
  , tx_subscriber_(uint64_t{0u})
  , tx_unsubscriber_(uint64_t{0u})
  , tx_packets_(uint64_t{0u})
  , tx_bytes_(uint64_t{0u})
  , tx_multicast_(uint64_t{0u})
  , tx_no_transmit_(uint64_t{0u})
  , tx_length_errors_(uint64_t{0u})
  , tx_no_channel_(uint64_t{0u})
  , tx_no_subscriber_(uint64_t{0u})
  , tx_no_endpoint_(uint64_t{0u})
  , tx_no_buffer_(uint64_t{0u})
  , valid_(false){}
struct KeyStatDefaultTypeInternal {
  constexpr KeyStatDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyStatDefaultTypeInternal() {}
  union {
    KeyStat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyStatDefaultTypeInternal _KeyStat_default_instance_;
constexpr Handle_MappingChannelsEntry_DoNotUse::Handle_MappingChannelsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct Handle_MappingChannelsEntry_DoNotUseDefaultTypeInternal {
  constexpr Handle_MappingChannelsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Handle_MappingChannelsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Handle_MappingChannelsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Handle_MappingChannelsEntry_DoNotUseDefaultTypeInternal _Handle_MappingChannelsEntry_DoNotUse_default_instance_;
constexpr Handle::Handle(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mapping_channels_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , owner_node_(nullptr)
  , owner_thread_(nullptr)
  , type_(0)

  , is_enabled_(false){}
struct HandleDefaultTypeInternal {
  constexpr HandleDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HandleDefaultTypeInternal() {}
  union {
    Handle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HandleDefaultTypeInternal _Handle_default_instance_;
constexpr AttachResponse::AttachResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : instance_(nullptr)
  , is_activated_(false){}
struct AttachResponseDefaultTypeInternal {
  constexpr AttachResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AttachResponseDefaultTypeInternal() {}
  union {
    AttachResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AttachResponseDefaultTypeInternal _AttachResponse_default_instance_;
constexpr Message::Message(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : payload_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , serialize_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , dir_(0)

  , is_pod_(false)
  , gen_timestamp_(uint64_t{0u})
  , tx_timestamp_(uint64_t{0u})
  , rx_timestamp_(uint64_t{0u})
  , write_timestamp_(uint64_t{0u})
  , read_timestamp_(uint64_t{0u}){}
struct MessageDefaultTypeInternal {
  constexpr MessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MessageDefaultTypeInternal() {}
  union {
    Message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MessageDefaultTypeInternal _Message_default_instance_;
constexpr MessageFields::MessageFields(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : has_flags_(0u){}
struct MessageFieldsDefaultTypeInternal {
  constexpr MessageFieldsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MessageFieldsDefaultTypeInternal() {}
  union {
    MessageFields _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MessageFieldsDefaultTypeInternal _MessageFields_default_instance_;
}  // namespace protocol
}  // namespace blackbox2
}  // namespace msgbus
}  // namespace asf
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_protocol_5fmessage_2eproto[18];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_protocol_5fmessage_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_protocol_5fmessage_2eproto = nullptr;

const uint32_t TableStruct_protocol_5fmessage_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Boolean, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Boolean, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::String, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::String, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Instance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Instance, id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Result, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Result, code_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Version, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Version, major_number_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Version, minor_number_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Version, patch_number_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Thread, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Thread, id_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Thread, name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Process, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Process, version_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Process, pid_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Process, name_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Process, cmdline_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Process, workding_directory_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Process, environments_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Process, config_filename_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Process, startup_timestamp_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Channel_ConfigEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Channel_ConfigEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Channel_ConfigEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Channel_ConfigEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Channel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Channel, owner_process_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Channel, owner_thread_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Channel, id_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Channel, type_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Channel, dir_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Channel, config_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Executor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Executor, owner_process_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Executor, owner_thread_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Executor, create_thread_id_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Executor, thread_pool_size_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Executor, is_runnning_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Executor, attached_nodes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::ExecutorTask, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::ExecutorTask, thread_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::ExecutorTask, task_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Node, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Node, owner_process_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Node, owner_thread_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Node, name_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Node, is_attached_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, valid_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, rx_subscriber_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, rx_unsubscriber_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, rx_packets_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, rx_bytes_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, rx_multicast_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, rx_length_errors_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, rx_no_buffer_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, rx_no_reader_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, tx_subscriber_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, tx_unsubscriber_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, tx_packets_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, tx_bytes_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, tx_multicast_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, tx_no_transmit_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, tx_length_errors_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, tx_no_channel_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, tx_no_subscriber_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, tx_no_endpoint_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::KeyStat, tx_no_buffer_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Handle_MappingChannelsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Handle_MappingChannelsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Handle_MappingChannelsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Handle_MappingChannelsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Handle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Handle, owner_node_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Handle, owner_thread_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Handle, type_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Handle, key_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Handle, is_enabled_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Handle, mapping_channels_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::AttachResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::AttachResponse, instance_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::AttachResponse, is_activated_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Message, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Message, dir_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Message, payload_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Message, is_pod_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Message, serialize_type_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Message, gen_timestamp_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Message, tx_timestamp_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Message, rx_timestamp_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Message, write_timestamp_),
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::Message, read_timestamp_),
  ~0u,
  0,
  2,
  1,
  3,
  4,
  5,
  6,
  7,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::MessageFields, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::asf::msgbus::blackbox2::protocol::MessageFields, has_flags_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::Boolean)},
  { 7, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::String)},
  { 14, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::Instance)},
  { 21, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::Result)},
  { 28, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::Version)},
  { 37, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::Thread)},
  { 45, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::Process)},
  { 59, 67, -1, sizeof(::asf::msgbus::blackbox2::protocol::Channel_ConfigEntry_DoNotUse)},
  { 69, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::Channel)},
  { 81, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::Executor)},
  { 93, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::ExecutorTask)},
  { 101, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::Node)},
  { 111, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::KeyStat)},
  { 137, 145, -1, sizeof(::asf::msgbus::blackbox2::protocol::Handle_MappingChannelsEntry_DoNotUse)},
  { 147, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::Handle)},
  { 159, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::AttachResponse)},
  { 167, 182, -1, sizeof(::asf::msgbus::blackbox2::protocol::Message)},
  { 191, -1, -1, sizeof(::asf::msgbus::blackbox2::protocol::MessageFields)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Boolean_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_String_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Instance_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Result_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Version_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Thread_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Process_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Channel_ConfigEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Channel_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Executor_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_ExecutorTask_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Node_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_KeyStat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Handle_MappingChannelsEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Handle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_AttachResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_Message_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::asf::msgbus::blackbox2::protocol::_MessageFields_default_instance_),
};

const char descriptor_table_protodef_protocol_5fmessage_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026protocol_message.proto\022\035asf.msgbus.bla"
  "ckbox2.protocol\"\030\n\007Boolean\022\r\n\005value\030\001 \001("
  "\010\"\027\n\006String\022\r\n\005value\030\001 \001(\t\"\026\n\010Instance\022\n"
  "\n\002id\030\001 \001(\004\"\026\n\006Result\022\014\n\004code\030\001 \001(\r\"K\n\007Ve"
  "rsion\022\024\n\014major_number\030\001 \001(\r\022\024\n\014minor_num"
  "ber\030\002 \001(\r\022\024\n\014patch_number\030\003 \001(\r\"\"\n\006Threa"
  "d\022\n\n\002id\030\001 \001(\004\022\014\n\004name\030\002 \001(\t\"\324\001\n\007Process\022"
  "7\n\007version\030\001 \001(\0132&.asf.msgbus.blackbox2."
  "protocol.Version\022\013\n\003pid\030\002 \001(\r\022\014\n\004name\030\003 "
  "\001(\t\022\017\n\007cmdline\030\004 \001(\t\022\032\n\022workding_directo"
  "ry\030\005 \001(\t\022\024\n\014environments\030\006 \001(\t\022\027\n\017config"
  "_filename\030\007 \001(\t\022\031\n\021startup_timestamp\030\010 \001"
  "(\004\"\312\002\n\007Channel\022>\n\rowner_process\030\001 \001(\0132\'."
  "asf.msgbus.blackbox2.protocol.Instance\022;"
  "\n\014owner_thread\030\002 \001(\0132%.asf.msgbus.blackb"
  "ox2.protocol.Thread\022\n\n\002id\030\003 \001(\t\022\014\n\004type\030"
  "\004 \001(\t\0225\n\003dir\030\005 \001(\0162(.asf.msgbus.blackbox"
  "2.protocol.Direction\022B\n\006config\030\006 \003(\01322.a"
  "sf.msgbus.blackbox2.protocol.Channel.Con"
  "figEntry\032-\n\013ConfigEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005"
  "value\030\002 \001(\t:\0028\001\"\350\001\n\010Executor\022>\n\rowner_pr"
  "ocess\030\001 \001(\0132\'.asf.msgbus.blackbox2.proto"
  "col.Instance\022;\n\014owner_thread\030\002 \001(\0132%.asf"
  ".msgbus.blackbox2.protocol.Thread\022\030\n\020cre"
  "ate_thread_id\030\003 \001(\r\022\030\n\020thread_pool_size\030"
  "\004 \001(\r\022\023\n\013is_runnning\030\005 \001(\010\022\026\n\016attached_n"
  "odes\030\006 \003(\t\"V\n\014ExecutorTask\0225\n\006thread\030\001 \001"
  "(\0132%.asf.msgbus.blackbox2.protocol.Threa"
  "d\022\017\n\007task_id\030\002 \001(\r\"\246\001\n\004Node\022>\n\rowner_pro"
  "cess\030\001 \001(\0132\'.asf.msgbus.blackbox2.protoc"
  "ol.Instance\022;\n\014owner_thread\030\002 \001(\0132%.asf."
  "msgbus.blackbox2.protocol.Thread\022\014\n\004name"
  "\030\003 \001(\t\022\023\n\013is_attached\030\004 \001(\010\"\307\003\n\007KeyStat\022"
  "\r\n\005valid\030\001 \001(\010\022\025\n\rrx_subscriber\030\002 \001(\004\022\027\n"
  "\017rx_unsubscriber\030\003 \001(\004\022\022\n\nrx_packets\030\004 \001"
  "(\004\022\020\n\010rx_bytes\030\005 \001(\004\022\024\n\014rx_multicast\030\006 \001"
  "(\004\022\030\n\020rx_length_errors\030\007 \001(\004\022\024\n\014rx_no_bu"
  "ffer\030\010 \001(\004\022\024\n\014rx_no_reader\030\t \001(\004\022\025\n\rtx_s"
  "ubscriber\030\n \001(\004\022\027\n\017tx_unsubscriber\030\013 \001(\004"
  "\022\022\n\ntx_packets\030\014 \001(\004\022\020\n\010tx_bytes\030\r \001(\004\022\024"
  "\n\014tx_multicast\030\016 \001(\004\022\026\n\016tx_no_transmit\030\017"
  " \001(\004\022\030\n\020tx_length_errors\030\020 \001(\004\022\025\n\rtx_no_"
  "channel\030\021 \001(\004\022\030\n\020tx_no_subscriber\030\022 \001(\004\022"
  "\026\n\016tx_no_endpoint\030\023 \001(\004\022\024\n\014tx_no_buffer\030"
  "\024 \001(\004\"\352\002\n\006Handle\022;\n\nowner_node\030\001 \001(\0132\'.a"
  "sf.msgbus.blackbox2.protocol.Instance\022;\n"
  "\014owner_thread\030\002 \001(\0132%.asf.msgbus.blackbo"
  "x2.protocol.Thread\0227\n\004type\030\003 \001(\0162).asf.m"
  "sgbus.blackbox2.protocol.HandleType\022\013\n\003k"
  "ey\030\004 \001(\t\022\022\n\nis_enabled\030\005 \001(\010\022T\n\020mapping_"
  "channels\030\006 \003(\0132:.asf.msgbus.blackbox2.pr"
  "otocol.Handle.MappingChannelsEntry\0326\n\024Ma"
  "ppingChannelsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value"
  "\030\002 \001(\t:\0028\001\"a\n\016AttachResponse\0229\n\010instance"
  "\030\001 \001(\0132\'.asf.msgbus.blackbox2.protocol.I"
  "nstance\022\024\n\014is_activated\030\002 \001(\010\"\232\003\n\007Messag"
  "e\0225\n\003dir\030\001 \001(\0162(.asf.msgbus.blackbox2.pr"
  "otocol.Direction\022\024\n\007payload\030\002 \001(\014H\000\210\001\001\022\023"
  "\n\006is_pod\030\003 \001(\010H\001\210\001\001\022\033\n\016serialize_type\030\004 "
  "\001(\tH\002\210\001\001\022\032\n\rgen_timestamp\030\005 \001(\004H\003\210\001\001\022\031\n\014"
  "tx_timestamp\030\006 \001(\004H\004\210\001\001\022\031\n\014rx_timestamp\030"
  "\007 \001(\004H\005\210\001\001\022\034\n\017write_timestamp\030\010 \001(\004H\006\210\001\001"
  "\022\033\n\016read_timestamp\030\t \001(\004H\007\210\001\001B\n\n\010_payloa"
  "dB\t\n\007_is_podB\021\n\017_serialize_typeB\020\n\016_gen_"
  "timestampB\017\n\r_tx_timestampB\017\n\r_rx_timest"
  "ampB\022\n\020_write_timestampB\021\n\017_read_timesta"
  "mp\"\"\n\rMessageFields\022\021\n\thas_flags\030\001 \001(\r*&"
  "\n\tDirection\022\006\n\002In\020\000\022\007\n\003Out\020\001\022\010\n\004Both\020\002*I"
  "\n\nHandleType\022\n\n\006Reader\020\000\022\n\n\006Writer\020\001\022\n\n\006"
  "Client\020\002\022\n\n\006Server\020\003\022\013\n\007Unknown\020\004b\006proto"
  "3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_protocol_5fmessage_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_5fmessage_2eproto = {
  false, false, 2801, descriptor_table_protodef_protocol_5fmessage_2eproto, "protocol_message.proto", 
  &descriptor_table_protocol_5fmessage_2eproto_once, nullptr, 0, 18,
  schemas, file_default_instances, TableStruct_protocol_5fmessage_2eproto::offsets,
  file_level_metadata_protocol_5fmessage_2eproto, file_level_enum_descriptors_protocol_5fmessage_2eproto, file_level_service_descriptors_protocol_5fmessage_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_protocol_5fmessage_2eproto_getter() {
  return &descriptor_table_protocol_5fmessage_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_protocol_5fmessage_2eproto(&descriptor_table_protocol_5fmessage_2eproto);
namespace asf {
namespace msgbus {
namespace blackbox2 {
namespace protocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Direction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_protocol_5fmessage_2eproto);
  return file_level_enum_descriptors_protocol_5fmessage_2eproto[0];
}
bool Direction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HandleType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_protocol_5fmessage_2eproto);
  return file_level_enum_descriptors_protocol_5fmessage_2eproto[1];
}
bool HandleType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Boolean::_Internal {
 public:
};

Boolean::Boolean(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.Boolean)
}
Boolean::Boolean(const Boolean& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.Boolean)
}

inline void Boolean::SharedCtor() {
value_ = false;
}

Boolean::~Boolean() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.Boolean)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Boolean::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Boolean::ArenaDtor(void* object) {
  Boolean* _this = reinterpret_cast< Boolean* >(object);
  (void)_this;
}
void Boolean::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Boolean::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Boolean::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.Boolean)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Boolean::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Boolean::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.Boolean)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.Boolean)
  return target;
}

size_t Boolean::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.Boolean)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool value = 1;
  if (this->_internal_value() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Boolean::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Boolean::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Boolean::GetClassData() const { return &_class_data_; }

void Boolean::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Boolean *>(to)->MergeFrom(
      static_cast<const Boolean &>(from));
}


void Boolean::MergeFrom(const Boolean& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.Boolean)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Boolean::CopyFrom(const Boolean& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.Boolean)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Boolean::IsInitialized() const {
  return true;
}

void Boolean::InternalSwap(Boolean* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Boolean::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[0]);
}

// ===================================================================

class String::_Internal {
 public:
};

String::String(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.String)
}
String::String(const String& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.String)
}

inline void String::SharedCtor() {
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

String::~String() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.String)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void String::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void String::ArenaDtor(void* object) {
  String* _this = reinterpret_cast< String* >(object);
  (void)_this;
}
void String::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void String::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void String::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.String)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* String::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.String.value"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* String::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.String)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string value = 1;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.String.value");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.String)
  return target;
}

size_t String::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.String)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string value = 1;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData String::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    String::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*String::GetClassData() const { return &_class_data_; }

void String::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<String *>(to)->MergeFrom(
      static_cast<const String &>(from));
}


void String::MergeFrom(const String& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.String)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void String::CopyFrom(const String& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.String)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool String::IsInitialized() const {
  return true;
}

void String::InternalSwap(String* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata String::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[1]);
}

// ===================================================================

class Instance::_Internal {
 public:
};

Instance::Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.Instance)
}
Instance::Instance(const Instance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.Instance)
}

inline void Instance::SharedCtor() {
id_ = uint64_t{0u};
}

Instance::~Instance() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.Instance)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Instance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Instance::ArenaDtor(void* object) {
  Instance* _this = reinterpret_cast< Instance* >(object);
  (void)_this;
}
void Instance::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Instance::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Instance::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.Instance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Instance::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Instance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.Instance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.Instance)
  return target;
}

size_t Instance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.Instance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Instance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Instance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Instance::GetClassData() const { return &_class_data_; }

void Instance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Instance *>(to)->MergeFrom(
      static_cast<const Instance &>(from));
}


void Instance::MergeFrom(const Instance& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.Instance)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _internal_set_id(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Instance::CopyFrom(const Instance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.Instance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Instance::IsInitialized() const {
  return true;
}

void Instance::InternalSwap(Instance* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Instance::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[2]);
}

// ===================================================================

class Result::_Internal {
 public:
};

Result::Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.Result)
}
Result::Result(const Result& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  code_ = from.code_;
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.Result)
}

inline void Result::SharedCtor() {
code_ = 0u;
}

Result::~Result() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.Result)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Result::ArenaDtor(void* object) {
  Result* _this = reinterpret_cast< Result* >(object);
  (void)_this;
}
void Result::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Result::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  code_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Result::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.Result)
  return target;
}

size_t Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 code = 1;
  if (this->_internal_code() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Result::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Result::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Result::GetClassData() const { return &_class_data_; }

void Result::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Result *>(to)->MergeFrom(
      static_cast<const Result &>(from));
}


void Result::MergeFrom(const Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_code() != 0) {
    _internal_set_code(from._internal_code());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Result::CopyFrom(const Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Result::IsInitialized() const {
  return true;
}

void Result::InternalSwap(Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(code_, other->code_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Result::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[3]);
}

// ===================================================================

class Version::_Internal {
 public:
};

Version::Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.Version)
}
Version::Version(const Version& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&major_number_, &from.major_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&patch_number_) -
    reinterpret_cast<char*>(&major_number_)) + sizeof(patch_number_));
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.Version)
}

inline void Version::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&major_number_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&patch_number_) -
    reinterpret_cast<char*>(&major_number_)) + sizeof(patch_number_));
}

Version::~Version() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.Version)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Version::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Version::ArenaDtor(void* object) {
  Version* _this = reinterpret_cast< Version* >(object);
  (void)_this;
}
void Version::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Version::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.Version)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&major_number_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&patch_number_) -
      reinterpret_cast<char*>(&major_number_)) + sizeof(patch_number_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Version::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 major_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          major_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 minor_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          minor_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 patch_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          patch_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Version::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.Version)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 major_number = 1;
  if (this->_internal_major_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_major_number(), target);
  }

  // uint32 minor_number = 2;
  if (this->_internal_minor_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_minor_number(), target);
  }

  // uint32 patch_number = 3;
  if (this->_internal_patch_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_patch_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.Version)
  return target;
}

size_t Version::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.Version)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 major_number = 1;
  if (this->_internal_major_number() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_major_number());
  }

  // uint32 minor_number = 2;
  if (this->_internal_minor_number() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_minor_number());
  }

  // uint32 patch_number = 3;
  if (this->_internal_patch_number() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_patch_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Version::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Version::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Version::GetClassData() const { return &_class_data_; }

void Version::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Version *>(to)->MergeFrom(
      static_cast<const Version &>(from));
}


void Version::MergeFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.Version)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_major_number() != 0) {
    _internal_set_major_number(from._internal_major_number());
  }
  if (from._internal_minor_number() != 0) {
    _internal_set_minor_number(from._internal_minor_number());
  }
  if (from._internal_patch_number() != 0) {
    _internal_set_patch_number(from._internal_patch_number());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Version::CopyFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  return true;
}

void Version::InternalSwap(Version* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Version, patch_number_)
      + sizeof(Version::patch_number_)
      - PROTOBUF_FIELD_OFFSET(Version, major_number_)>(
          reinterpret_cast<char*>(&major_number_),
          reinterpret_cast<char*>(&other->major_number_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Version::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[4]);
}

// ===================================================================

class Thread::_Internal {
 public:
};

Thread::Thread(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.Thread)
}
Thread::Thread(const Thread& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.Thread)
}

inline void Thread::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
id_ = uint64_t{0u};
}

Thread::~Thread() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.Thread)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Thread::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Thread::ArenaDtor(void* object) {
  Thread* _this = reinterpret_cast< Thread* >(object);
  (void)_this;
}
void Thread::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Thread::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Thread::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.Thread)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Thread::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Thread.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Thread::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.Thread)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Thread.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.Thread)
  return target;
}

size_t Thread::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.Thread)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Thread::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Thread::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Thread::GetClassData() const { return &_class_data_; }

void Thread::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Thread *>(to)->MergeFrom(
      static_cast<const Thread &>(from));
}


void Thread::MergeFrom(const Thread& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.Thread)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_id() != 0) {
    _internal_set_id(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Thread::CopyFrom(const Thread& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.Thread)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Thread::IsInitialized() const {
  return true;
}

void Thread::InternalSwap(Thread* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Thread::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[5]);
}

// ===================================================================

class Process::_Internal {
 public:
  static const ::asf::msgbus::blackbox2::protocol::Version& version(const Process* msg);
};

const ::asf::msgbus::blackbox2::protocol::Version&
Process::_Internal::version(const Process* msg) {
  return *msg->version_;
}
Process::Process(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.Process)
}
Process::Process(const Process& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  cmdline_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cmdline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cmdline().empty()) {
    cmdline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_cmdline(), 
      GetArenaForAllocation());
  }
  workding_directory_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    workding_directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_workding_directory().empty()) {
    workding_directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_workding_directory(), 
      GetArenaForAllocation());
  }
  environments_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    environments_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_environments().empty()) {
    environments_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_environments(), 
      GetArenaForAllocation());
  }
  config_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    config_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_config_filename().empty()) {
    config_filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_config_filename(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_version()) {
    version_ = new ::asf::msgbus::blackbox2::protocol::Version(*from.version_);
  } else {
    version_ = nullptr;
  }
  ::memcpy(&startup_timestamp_, &from.startup_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&pid_) -
    reinterpret_cast<char*>(&startup_timestamp_)) + sizeof(pid_));
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.Process)
}

inline void Process::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cmdline_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cmdline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
workding_directory_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  workding_directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
environments_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  environments_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
config_filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  config_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&version_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pid_) -
    reinterpret_cast<char*>(&version_)) + sizeof(pid_));
}

Process::~Process() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.Process)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Process::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cmdline_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  workding_directory_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  environments_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  config_filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete version_;
}

void Process::ArenaDtor(void* object) {
  Process* _this = reinterpret_cast< Process* >(object);
  (void)_this;
}
void Process::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Process::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Process::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.Process)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  cmdline_.ClearToEmpty();
  workding_directory_.ClearToEmpty();
  environments_.ClearToEmpty();
  config_filename_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && version_ != nullptr) {
    delete version_;
  }
  version_ = nullptr;
  ::memset(&startup_timestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pid_) -
      reinterpret_cast<char*>(&startup_timestamp_)) + sizeof(pid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Process::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .asf.msgbus.blackbox2.protocol.Version version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_version(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Process.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string cmdline = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_cmdline();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Process.cmdline"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string workding_directory = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_workding_directory();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Process.workding_directory"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string environments = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_environments();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Process.environments"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string config_filename = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_config_filename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Process.config_filename"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 startup_timestamp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          startup_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Process::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.Process)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .asf.msgbus.blackbox2.protocol.Version version = 1;
  if (this->_internal_has_version()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::version(this), target, stream);
  }

  // uint32 pid = 2;
  if (this->_internal_pid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_pid(), target);
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Process.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // string cmdline = 4;
  if (!this->_internal_cmdline().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_cmdline().data(), static_cast<int>(this->_internal_cmdline().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Process.cmdline");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_cmdline(), target);
  }

  // string workding_directory = 5;
  if (!this->_internal_workding_directory().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_workding_directory().data(), static_cast<int>(this->_internal_workding_directory().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Process.workding_directory");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_workding_directory(), target);
  }

  // string environments = 6;
  if (!this->_internal_environments().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_environments().data(), static_cast<int>(this->_internal_environments().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Process.environments");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_environments(), target);
  }

  // string config_filename = 7;
  if (!this->_internal_config_filename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_config_filename().data(), static_cast<int>(this->_internal_config_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Process.config_filename");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_config_filename(), target);
  }

  // uint64 startup_timestamp = 8;
  if (this->_internal_startup_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_startup_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.Process)
  return target;
}

size_t Process::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.Process)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 3;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string cmdline = 4;
  if (!this->_internal_cmdline().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cmdline());
  }

  // string workding_directory = 5;
  if (!this->_internal_workding_directory().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_workding_directory());
  }

  // string environments = 6;
  if (!this->_internal_environments().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_environments());
  }

  // string config_filename = 7;
  if (!this->_internal_config_filename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_config_filename());
  }

  // .asf.msgbus.blackbox2.protocol.Version version = 1;
  if (this->_internal_has_version()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *version_);
  }

  // uint64 startup_timestamp = 8;
  if (this->_internal_startup_timestamp() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_startup_timestamp());
  }

  // uint32 pid = 2;
  if (this->_internal_pid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_pid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Process::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Process::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Process::GetClassData() const { return &_class_data_; }

void Process::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Process *>(to)->MergeFrom(
      static_cast<const Process &>(from));
}


void Process::MergeFrom(const Process& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.Process)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_cmdline().empty()) {
    _internal_set_cmdline(from._internal_cmdline());
  }
  if (!from._internal_workding_directory().empty()) {
    _internal_set_workding_directory(from._internal_workding_directory());
  }
  if (!from._internal_environments().empty()) {
    _internal_set_environments(from._internal_environments());
  }
  if (!from._internal_config_filename().empty()) {
    _internal_set_config_filename(from._internal_config_filename());
  }
  if (from._internal_has_version()) {
    _internal_mutable_version()->::asf::msgbus::blackbox2::protocol::Version::MergeFrom(from._internal_version());
  }
  if (from._internal_startup_timestamp() != 0) {
    _internal_set_startup_timestamp(from._internal_startup_timestamp());
  }
  if (from._internal_pid() != 0) {
    _internal_set_pid(from._internal_pid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Process::CopyFrom(const Process& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.Process)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Process::IsInitialized() const {
  return true;
}

void Process::InternalSwap(Process* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &cmdline_, lhs_arena,
      &other->cmdline_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &workding_directory_, lhs_arena,
      &other->workding_directory_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &environments_, lhs_arena,
      &other->environments_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &config_filename_, lhs_arena,
      &other->config_filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Process, pid_)
      + sizeof(Process::pid_)
      - PROTOBUF_FIELD_OFFSET(Process, version_)>(
          reinterpret_cast<char*>(&version_),
          reinterpret_cast<char*>(&other->version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Process::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[6]);
}

// ===================================================================

Channel_ConfigEntry_DoNotUse::Channel_ConfigEntry_DoNotUse() {}
Channel_ConfigEntry_DoNotUse::Channel_ConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Channel_ConfigEntry_DoNotUse::MergeFrom(const Channel_ConfigEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata Channel_ConfigEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[7]);
}

// ===================================================================

class Channel::_Internal {
 public:
  static const ::asf::msgbus::blackbox2::protocol::Instance& owner_process(const Channel* msg);
  static const ::asf::msgbus::blackbox2::protocol::Thread& owner_thread(const Channel* msg);
};

const ::asf::msgbus::blackbox2::protocol::Instance&
Channel::_Internal::owner_process(const Channel* msg) {
  return *msg->owner_process_;
}
const ::asf::msgbus::blackbox2::protocol::Thread&
Channel::_Internal::owner_thread(const Channel* msg) {
  return *msg->owner_thread_;
}
Channel::Channel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  config_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.Channel)
}
Channel::Channel(const Channel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  config_.MergeFrom(from.config_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArenaForAllocation());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_owner_process()) {
    owner_process_ = new ::asf::msgbus::blackbox2::protocol::Instance(*from.owner_process_);
  } else {
    owner_process_ = nullptr;
  }
  if (from._internal_has_owner_thread()) {
    owner_thread_ = new ::asf::msgbus::blackbox2::protocol::Thread(*from.owner_thread_);
  } else {
    owner_thread_ = nullptr;
  }
  dir_ = from.dir_;
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.Channel)
}

inline void Channel::SharedCtor() {
id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&owner_process_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dir_) -
    reinterpret_cast<char*>(&owner_process_)) + sizeof(dir_));
}

Channel::~Channel() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.Channel)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Channel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete owner_process_;
  if (this != internal_default_instance()) delete owner_thread_;
}

void Channel::ArenaDtor(void* object) {
  Channel* _this = reinterpret_cast< Channel* >(object);
  (void)_this;
  _this->config_. ~MapField();
}
inline void Channel::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &Channel::ArenaDtor);
  }
}
void Channel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Channel::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.Channel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  config_.Clear();
  id_.ClearToEmpty();
  type_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && owner_process_ != nullptr) {
    delete owner_process_;
  }
  owner_process_ = nullptr;
  if (GetArenaForAllocation() == nullptr && owner_thread_ != nullptr) {
    delete owner_thread_;
  }
  owner_thread_ = nullptr;
  dir_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Channel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_process(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_thread(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Channel.id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Channel.type"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .asf.msgbus.blackbox2.protocol.Direction dir = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dir(static_cast<::asf::msgbus::blackbox2::protocol::Direction>(val));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> config = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&config_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Channel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.Channel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
  if (this->_internal_has_owner_process()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::owner_process(this), target, stream);
  }

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  if (this->_internal_has_owner_thread()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::owner_thread(this), target, stream);
  }

  // string id = 3;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Channel.id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_id(), target);
  }

  // string type = 4;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Channel.type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_type(), target);
  }

  // .asf.msgbus.blackbox2.protocol.Direction dir = 5;
  if (this->_internal_dir() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_dir(), target);
  }

  // map<string, string> config = 6;
  if (!this->_internal_config().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "asf.msgbus.blackbox2.protocol.Channel.ConfigEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "asf.msgbus.blackbox2.protocol.Channel.ConfigEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_config().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_config().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_config().begin();
          it != this->_internal_config().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Channel_ConfigEntry_DoNotUse::Funcs::InternalSerialize(6, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_config().begin();
          it != this->_internal_config().end(); ++it) {
        target = Channel_ConfigEntry_DoNotUse::Funcs::InternalSerialize(6, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.Channel)
  return target;
}

size_t Channel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.Channel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> config = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_config_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_config().begin();
      it != this->_internal_config().end(); ++it) {
    total_size += Channel_ConfigEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string id = 3;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string type = 4;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
  if (this->_internal_has_owner_process()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_process_);
  }

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  if (this->_internal_has_owner_thread()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_thread_);
  }

  // .asf.msgbus.blackbox2.protocol.Direction dir = 5;
  if (this->_internal_dir() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_dir());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Channel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Channel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Channel::GetClassData() const { return &_class_data_; }

void Channel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Channel *>(to)->MergeFrom(
      static_cast<const Channel &>(from));
}


void Channel::MergeFrom(const Channel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.Channel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  config_.MergeFrom(from.config_);
  if (!from._internal_id().empty()) {
    _internal_set_id(from._internal_id());
  }
  if (!from._internal_type().empty()) {
    _internal_set_type(from._internal_type());
  }
  if (from._internal_has_owner_process()) {
    _internal_mutable_owner_process()->::asf::msgbus::blackbox2::protocol::Instance::MergeFrom(from._internal_owner_process());
  }
  if (from._internal_has_owner_thread()) {
    _internal_mutable_owner_thread()->::asf::msgbus::blackbox2::protocol::Thread::MergeFrom(from._internal_owner_thread());
  }
  if (from._internal_dir() != 0) {
    _internal_set_dir(from._internal_dir());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Channel::CopyFrom(const Channel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.Channel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Channel::IsInitialized() const {
  return true;
}

void Channel::InternalSwap(Channel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  config_.InternalSwap(&other->config_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Channel, dir_)
      + sizeof(Channel::dir_)
      - PROTOBUF_FIELD_OFFSET(Channel, owner_process_)>(
          reinterpret_cast<char*>(&owner_process_),
          reinterpret_cast<char*>(&other->owner_process_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Channel::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[8]);
}

// ===================================================================

class Executor::_Internal {
 public:
  static const ::asf::msgbus::blackbox2::protocol::Instance& owner_process(const Executor* msg);
  static const ::asf::msgbus::blackbox2::protocol::Thread& owner_thread(const Executor* msg);
};

const ::asf::msgbus::blackbox2::protocol::Instance&
Executor::_Internal::owner_process(const Executor* msg) {
  return *msg->owner_process_;
}
const ::asf::msgbus::blackbox2::protocol::Thread&
Executor::_Internal::owner_thread(const Executor* msg) {
  return *msg->owner_thread_;
}
Executor::Executor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  attached_nodes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.Executor)
}
Executor::Executor(const Executor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      attached_nodes_(from.attached_nodes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_owner_process()) {
    owner_process_ = new ::asf::msgbus::blackbox2::protocol::Instance(*from.owner_process_);
  } else {
    owner_process_ = nullptr;
  }
  if (from._internal_has_owner_thread()) {
    owner_thread_ = new ::asf::msgbus::blackbox2::protocol::Thread(*from.owner_thread_);
  } else {
    owner_thread_ = nullptr;
  }
  ::memcpy(&create_thread_id_, &from.create_thread_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_runnning_) -
    reinterpret_cast<char*>(&create_thread_id_)) + sizeof(is_runnning_));
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.Executor)
}

inline void Executor::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&owner_process_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_runnning_) -
    reinterpret_cast<char*>(&owner_process_)) + sizeof(is_runnning_));
}

Executor::~Executor() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.Executor)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Executor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete owner_process_;
  if (this != internal_default_instance()) delete owner_thread_;
}

void Executor::ArenaDtor(void* object) {
  Executor* _this = reinterpret_cast< Executor* >(object);
  (void)_this;
}
void Executor::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Executor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Executor::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.Executor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  attached_nodes_.Clear();
  if (GetArenaForAllocation() == nullptr && owner_process_ != nullptr) {
    delete owner_process_;
  }
  owner_process_ = nullptr;
  if (GetArenaForAllocation() == nullptr && owner_thread_ != nullptr) {
    delete owner_thread_;
  }
  owner_thread_ = nullptr;
  ::memset(&create_thread_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_runnning_) -
      reinterpret_cast<char*>(&create_thread_id_)) + sizeof(is_runnning_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Executor::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_process(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_thread(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 create_thread_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          create_thread_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 thread_pool_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          thread_pool_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_runnning = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          is_runnning_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string attached_nodes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_attached_nodes();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Executor.attached_nodes"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Executor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.Executor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
  if (this->_internal_has_owner_process()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::owner_process(this), target, stream);
  }

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  if (this->_internal_has_owner_thread()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::owner_thread(this), target, stream);
  }

  // uint32 create_thread_id = 3;
  if (this->_internal_create_thread_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_create_thread_id(), target);
  }

  // uint32 thread_pool_size = 4;
  if (this->_internal_thread_pool_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_thread_pool_size(), target);
  }

  // bool is_runnning = 5;
  if (this->_internal_is_runnning() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_runnning(), target);
  }

  // repeated string attached_nodes = 6;
  for (int i = 0, n = this->_internal_attached_nodes_size(); i < n; i++) {
    const auto& s = this->_internal_attached_nodes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Executor.attached_nodes");
    target = stream->WriteString(6, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.Executor)
  return target;
}

size_t Executor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.Executor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string attached_nodes = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(attached_nodes_.size());
  for (int i = 0, n = attached_nodes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      attached_nodes_.Get(i));
  }

  // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
  if (this->_internal_has_owner_process()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_process_);
  }

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  if (this->_internal_has_owner_thread()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_thread_);
  }

  // uint32 create_thread_id = 3;
  if (this->_internal_create_thread_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_create_thread_id());
  }

  // uint32 thread_pool_size = 4;
  if (this->_internal_thread_pool_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_thread_pool_size());
  }

  // bool is_runnning = 5;
  if (this->_internal_is_runnning() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Executor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Executor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Executor::GetClassData() const { return &_class_data_; }

void Executor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Executor *>(to)->MergeFrom(
      static_cast<const Executor &>(from));
}


void Executor::MergeFrom(const Executor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.Executor)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  attached_nodes_.MergeFrom(from.attached_nodes_);
  if (from._internal_has_owner_process()) {
    _internal_mutable_owner_process()->::asf::msgbus::blackbox2::protocol::Instance::MergeFrom(from._internal_owner_process());
  }
  if (from._internal_has_owner_thread()) {
    _internal_mutable_owner_thread()->::asf::msgbus::blackbox2::protocol::Thread::MergeFrom(from._internal_owner_thread());
  }
  if (from._internal_create_thread_id() != 0) {
    _internal_set_create_thread_id(from._internal_create_thread_id());
  }
  if (from._internal_thread_pool_size() != 0) {
    _internal_set_thread_pool_size(from._internal_thread_pool_size());
  }
  if (from._internal_is_runnning() != 0) {
    _internal_set_is_runnning(from._internal_is_runnning());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Executor::CopyFrom(const Executor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.Executor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Executor::IsInitialized() const {
  return true;
}

void Executor::InternalSwap(Executor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  attached_nodes_.InternalSwap(&other->attached_nodes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Executor, is_runnning_)
      + sizeof(Executor::is_runnning_)
      - PROTOBUF_FIELD_OFFSET(Executor, owner_process_)>(
          reinterpret_cast<char*>(&owner_process_),
          reinterpret_cast<char*>(&other->owner_process_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Executor::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[9]);
}

// ===================================================================

class ExecutorTask::_Internal {
 public:
  static const ::asf::msgbus::blackbox2::protocol::Thread& thread(const ExecutorTask* msg);
};

const ::asf::msgbus::blackbox2::protocol::Thread&
ExecutorTask::_Internal::thread(const ExecutorTask* msg) {
  return *msg->thread_;
}
ExecutorTask::ExecutorTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.ExecutorTask)
}
ExecutorTask::ExecutorTask(const ExecutorTask& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_thread()) {
    thread_ = new ::asf::msgbus::blackbox2::protocol::Thread(*from.thread_);
  } else {
    thread_ = nullptr;
  }
  task_id_ = from.task_id_;
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.ExecutorTask)
}

inline void ExecutorTask::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&thread_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&task_id_) -
    reinterpret_cast<char*>(&thread_)) + sizeof(task_id_));
}

ExecutorTask::~ExecutorTask() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.ExecutorTask)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ExecutorTask::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete thread_;
}

void ExecutorTask::ArenaDtor(void* object) {
  ExecutorTask* _this = reinterpret_cast< ExecutorTask* >(object);
  (void)_this;
}
void ExecutorTask::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ExecutorTask::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExecutorTask::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.ExecutorTask)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && thread_ != nullptr) {
    delete thread_;
  }
  thread_ = nullptr;
  task_id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExecutorTask::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .asf.msgbus.blackbox2.protocol.Thread thread = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_thread(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 task_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          task_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExecutorTask::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.ExecutorTask)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .asf.msgbus.blackbox2.protocol.Thread thread = 1;
  if (this->_internal_has_thread()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::thread(this), target, stream);
  }

  // uint32 task_id = 2;
  if (this->_internal_task_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_task_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.ExecutorTask)
  return target;
}

size_t ExecutorTask::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.ExecutorTask)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .asf.msgbus.blackbox2.protocol.Thread thread = 1;
  if (this->_internal_has_thread()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *thread_);
  }

  // uint32 task_id = 2;
  if (this->_internal_task_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_task_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExecutorTask::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ExecutorTask::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExecutorTask::GetClassData() const { return &_class_data_; }

void ExecutorTask::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ExecutorTask *>(to)->MergeFrom(
      static_cast<const ExecutorTask &>(from));
}


void ExecutorTask::MergeFrom(const ExecutorTask& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.ExecutorTask)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_thread()) {
    _internal_mutable_thread()->::asf::msgbus::blackbox2::protocol::Thread::MergeFrom(from._internal_thread());
  }
  if (from._internal_task_id() != 0) {
    _internal_set_task_id(from._internal_task_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExecutorTask::CopyFrom(const ExecutorTask& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.ExecutorTask)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutorTask::IsInitialized() const {
  return true;
}

void ExecutorTask::InternalSwap(ExecutorTask* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExecutorTask, task_id_)
      + sizeof(ExecutorTask::task_id_)
      - PROTOBUF_FIELD_OFFSET(ExecutorTask, thread_)>(
          reinterpret_cast<char*>(&thread_),
          reinterpret_cast<char*>(&other->thread_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExecutorTask::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[10]);
}

// ===================================================================

class Node::_Internal {
 public:
  static const ::asf::msgbus::blackbox2::protocol::Instance& owner_process(const Node* msg);
  static const ::asf::msgbus::blackbox2::protocol::Thread& owner_thread(const Node* msg);
};

const ::asf::msgbus::blackbox2::protocol::Instance&
Node::_Internal::owner_process(const Node* msg) {
  return *msg->owner_process_;
}
const ::asf::msgbus::blackbox2::protocol::Thread&
Node::_Internal::owner_thread(const Node* msg) {
  return *msg->owner_thread_;
}
Node::Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.Node)
}
Node::Node(const Node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_owner_process()) {
    owner_process_ = new ::asf::msgbus::blackbox2::protocol::Instance(*from.owner_process_);
  } else {
    owner_process_ = nullptr;
  }
  if (from._internal_has_owner_thread()) {
    owner_thread_ = new ::asf::msgbus::blackbox2::protocol::Thread(*from.owner_thread_);
  } else {
    owner_thread_ = nullptr;
  }
  is_attached_ = from.is_attached_;
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.Node)
}

inline void Node::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&owner_process_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_attached_) -
    reinterpret_cast<char*>(&owner_process_)) + sizeof(is_attached_));
}

Node::~Node() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.Node)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete owner_process_;
  if (this != internal_default_instance()) delete owner_thread_;
}

void Node::ArenaDtor(void* object) {
  Node* _this = reinterpret_cast< Node* >(object);
  (void)_this;
}
void Node::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Node::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Node::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && owner_process_ != nullptr) {
    delete owner_process_;
  }
  owner_process_ = nullptr;
  if (GetArenaForAllocation() == nullptr && owner_thread_ != nullptr) {
    delete owner_thread_;
  }
  owner_thread_ = nullptr;
  is_attached_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Node::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_process(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_thread(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Node.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_attached = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          is_attached_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
  if (this->_internal_has_owner_process()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::owner_process(this), target, stream);
  }

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  if (this->_internal_has_owner_thread()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::owner_thread(this), target, stream);
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Node.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // bool is_attached = 4;
  if (this->_internal_is_attached() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_attached(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.Node)
  return target;
}

size_t Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.Node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 3;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .asf.msgbus.blackbox2.protocol.Instance owner_process = 1;
  if (this->_internal_has_owner_process()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_process_);
  }

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  if (this->_internal_has_owner_thread()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_thread_);
  }

  // bool is_attached = 4;
  if (this->_internal_is_attached() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Node::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Node::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Node::GetClassData() const { return &_class_data_; }

void Node::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Node *>(to)->MergeFrom(
      static_cast<const Node &>(from));
}


void Node::MergeFrom(const Node& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.Node)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_owner_process()) {
    _internal_mutable_owner_process()->::asf::msgbus::blackbox2::protocol::Instance::MergeFrom(from._internal_owner_process());
  }
  if (from._internal_has_owner_thread()) {
    _internal_mutable_owner_thread()->::asf::msgbus::blackbox2::protocol::Thread::MergeFrom(from._internal_owner_thread());
  }
  if (from._internal_is_attached() != 0) {
    _internal_set_is_attached(from._internal_is_attached());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Node::CopyFrom(const Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Node::IsInitialized() const {
  return true;
}

void Node::InternalSwap(Node* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Node, is_attached_)
      + sizeof(Node::is_attached_)
      - PROTOBUF_FIELD_OFFSET(Node, owner_process_)>(
          reinterpret_cast<char*>(&owner_process_),
          reinterpret_cast<char*>(&other->owner_process_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Node::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[11]);
}

// ===================================================================

class KeyStat::_Internal {
 public:
};

KeyStat::KeyStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.KeyStat)
}
KeyStat::KeyStat(const KeyStat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&rx_subscriber_, &from.rx_subscriber_,
    static_cast<size_t>(reinterpret_cast<char*>(&valid_) -
    reinterpret_cast<char*>(&rx_subscriber_)) + sizeof(valid_));
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.KeyStat)
}

inline void KeyStat::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rx_subscriber_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&valid_) -
    reinterpret_cast<char*>(&rx_subscriber_)) + sizeof(valid_));
}

KeyStat::~KeyStat() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.KeyStat)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KeyStat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KeyStat::ArenaDtor(void* object) {
  KeyStat* _this = reinterpret_cast< KeyStat* >(object);
  (void)_this;
}
void KeyStat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyStat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyStat::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.KeyStat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&rx_subscriber_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&valid_) -
      reinterpret_cast<char*>(&rx_subscriber_)) + sizeof(valid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyStat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool valid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_subscriber = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          rx_subscriber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_unsubscriber = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          rx_unsubscriber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_packets = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          rx_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_bytes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          rx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_multicast = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          rx_multicast_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_length_errors = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          rx_length_errors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_no_buffer = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          rx_no_buffer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 rx_no_reader = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          rx_no_reader_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_subscriber = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          tx_subscriber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_unsubscriber = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          tx_unsubscriber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_packets = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          tx_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_bytes = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          tx_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_multicast = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          tx_multicast_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_no_transmit = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          tx_no_transmit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_length_errors = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          tx_length_errors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_no_channel = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          tx_no_channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_no_subscriber = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          tx_no_subscriber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_no_endpoint = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          tx_no_endpoint_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_no_buffer = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          tx_no_buffer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyStat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.KeyStat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool valid = 1;
  if (this->_internal_valid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_valid(), target);
  }

  // uint64 rx_subscriber = 2;
  if (this->_internal_rx_subscriber() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_rx_subscriber(), target);
  }

  // uint64 rx_unsubscriber = 3;
  if (this->_internal_rx_unsubscriber() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_rx_unsubscriber(), target);
  }

  // uint64 rx_packets = 4;
  if (this->_internal_rx_packets() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_rx_packets(), target);
  }

  // uint64 rx_bytes = 5;
  if (this->_internal_rx_bytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_rx_bytes(), target);
  }

  // uint64 rx_multicast = 6;
  if (this->_internal_rx_multicast() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_rx_multicast(), target);
  }

  // uint64 rx_length_errors = 7;
  if (this->_internal_rx_length_errors() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_rx_length_errors(), target);
  }

  // uint64 rx_no_buffer = 8;
  if (this->_internal_rx_no_buffer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_rx_no_buffer(), target);
  }

  // uint64 rx_no_reader = 9;
  if (this->_internal_rx_no_reader() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_rx_no_reader(), target);
  }

  // uint64 tx_subscriber = 10;
  if (this->_internal_tx_subscriber() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(10, this->_internal_tx_subscriber(), target);
  }

  // uint64 tx_unsubscriber = 11;
  if (this->_internal_tx_unsubscriber() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(11, this->_internal_tx_unsubscriber(), target);
  }

  // uint64 tx_packets = 12;
  if (this->_internal_tx_packets() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(12, this->_internal_tx_packets(), target);
  }

  // uint64 tx_bytes = 13;
  if (this->_internal_tx_bytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(13, this->_internal_tx_bytes(), target);
  }

  // uint64 tx_multicast = 14;
  if (this->_internal_tx_multicast() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(14, this->_internal_tx_multicast(), target);
  }

  // uint64 tx_no_transmit = 15;
  if (this->_internal_tx_no_transmit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(15, this->_internal_tx_no_transmit(), target);
  }

  // uint64 tx_length_errors = 16;
  if (this->_internal_tx_length_errors() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(16, this->_internal_tx_length_errors(), target);
  }

  // uint64 tx_no_channel = 17;
  if (this->_internal_tx_no_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(17, this->_internal_tx_no_channel(), target);
  }

  // uint64 tx_no_subscriber = 18;
  if (this->_internal_tx_no_subscriber() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(18, this->_internal_tx_no_subscriber(), target);
  }

  // uint64 tx_no_endpoint = 19;
  if (this->_internal_tx_no_endpoint() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(19, this->_internal_tx_no_endpoint(), target);
  }

  // uint64 tx_no_buffer = 20;
  if (this->_internal_tx_no_buffer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(20, this->_internal_tx_no_buffer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.KeyStat)
  return target;
}

size_t KeyStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.KeyStat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 rx_subscriber = 2;
  if (this->_internal_rx_subscriber() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_subscriber());
  }

  // uint64 rx_unsubscriber = 3;
  if (this->_internal_rx_unsubscriber() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_unsubscriber());
  }

  // uint64 rx_packets = 4;
  if (this->_internal_rx_packets() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_packets());
  }

  // uint64 rx_bytes = 5;
  if (this->_internal_rx_bytes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_bytes());
  }

  // uint64 rx_multicast = 6;
  if (this->_internal_rx_multicast() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_multicast());
  }

  // uint64 rx_length_errors = 7;
  if (this->_internal_rx_length_errors() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_length_errors());
  }

  // uint64 rx_no_buffer = 8;
  if (this->_internal_rx_no_buffer() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_no_buffer());
  }

  // uint64 rx_no_reader = 9;
  if (this->_internal_rx_no_reader() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_no_reader());
  }

  // uint64 tx_subscriber = 10;
  if (this->_internal_tx_subscriber() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tx_subscriber());
  }

  // uint64 tx_unsubscriber = 11;
  if (this->_internal_tx_unsubscriber() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tx_unsubscriber());
  }

  // uint64 tx_packets = 12;
  if (this->_internal_tx_packets() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tx_packets());
  }

  // uint64 tx_bytes = 13;
  if (this->_internal_tx_bytes() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tx_bytes());
  }

  // uint64 tx_multicast = 14;
  if (this->_internal_tx_multicast() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tx_multicast());
  }

  // uint64 tx_no_transmit = 15;
  if (this->_internal_tx_no_transmit() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tx_no_transmit());
  }

  // uint64 tx_length_errors = 16;
  if (this->_internal_tx_length_errors() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_tx_length_errors());
  }

  // uint64 tx_no_channel = 17;
  if (this->_internal_tx_no_channel() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_tx_no_channel());
  }

  // uint64 tx_no_subscriber = 18;
  if (this->_internal_tx_no_subscriber() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_tx_no_subscriber());
  }

  // uint64 tx_no_endpoint = 19;
  if (this->_internal_tx_no_endpoint() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_tx_no_endpoint());
  }

  // uint64 tx_no_buffer = 20;
  if (this->_internal_tx_no_buffer() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_tx_no_buffer());
  }

  // bool valid = 1;
  if (this->_internal_valid() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyStat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KeyStat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyStat::GetClassData() const { return &_class_data_; }

void KeyStat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KeyStat *>(to)->MergeFrom(
      static_cast<const KeyStat &>(from));
}


void KeyStat::MergeFrom(const KeyStat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.KeyStat)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_rx_subscriber() != 0) {
    _internal_set_rx_subscriber(from._internal_rx_subscriber());
  }
  if (from._internal_rx_unsubscriber() != 0) {
    _internal_set_rx_unsubscriber(from._internal_rx_unsubscriber());
  }
  if (from._internal_rx_packets() != 0) {
    _internal_set_rx_packets(from._internal_rx_packets());
  }
  if (from._internal_rx_bytes() != 0) {
    _internal_set_rx_bytes(from._internal_rx_bytes());
  }
  if (from._internal_rx_multicast() != 0) {
    _internal_set_rx_multicast(from._internal_rx_multicast());
  }
  if (from._internal_rx_length_errors() != 0) {
    _internal_set_rx_length_errors(from._internal_rx_length_errors());
  }
  if (from._internal_rx_no_buffer() != 0) {
    _internal_set_rx_no_buffer(from._internal_rx_no_buffer());
  }
  if (from._internal_rx_no_reader() != 0) {
    _internal_set_rx_no_reader(from._internal_rx_no_reader());
  }
  if (from._internal_tx_subscriber() != 0) {
    _internal_set_tx_subscriber(from._internal_tx_subscriber());
  }
  if (from._internal_tx_unsubscriber() != 0) {
    _internal_set_tx_unsubscriber(from._internal_tx_unsubscriber());
  }
  if (from._internal_tx_packets() != 0) {
    _internal_set_tx_packets(from._internal_tx_packets());
  }
  if (from._internal_tx_bytes() != 0) {
    _internal_set_tx_bytes(from._internal_tx_bytes());
  }
  if (from._internal_tx_multicast() != 0) {
    _internal_set_tx_multicast(from._internal_tx_multicast());
  }
  if (from._internal_tx_no_transmit() != 0) {
    _internal_set_tx_no_transmit(from._internal_tx_no_transmit());
  }
  if (from._internal_tx_length_errors() != 0) {
    _internal_set_tx_length_errors(from._internal_tx_length_errors());
  }
  if (from._internal_tx_no_channel() != 0) {
    _internal_set_tx_no_channel(from._internal_tx_no_channel());
  }
  if (from._internal_tx_no_subscriber() != 0) {
    _internal_set_tx_no_subscriber(from._internal_tx_no_subscriber());
  }
  if (from._internal_tx_no_endpoint() != 0) {
    _internal_set_tx_no_endpoint(from._internal_tx_no_endpoint());
  }
  if (from._internal_tx_no_buffer() != 0) {
    _internal_set_tx_no_buffer(from._internal_tx_no_buffer());
  }
  if (from._internal_valid() != 0) {
    _internal_set_valid(from._internal_valid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyStat::CopyFrom(const KeyStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.KeyStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyStat::IsInitialized() const {
  return true;
}

void KeyStat::InternalSwap(KeyStat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyStat, valid_)
      + sizeof(KeyStat::valid_)
      - PROTOBUF_FIELD_OFFSET(KeyStat, rx_subscriber_)>(
          reinterpret_cast<char*>(&rx_subscriber_),
          reinterpret_cast<char*>(&other->rx_subscriber_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyStat::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[12]);
}

// ===================================================================

Handle_MappingChannelsEntry_DoNotUse::Handle_MappingChannelsEntry_DoNotUse() {}
Handle_MappingChannelsEntry_DoNotUse::Handle_MappingChannelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Handle_MappingChannelsEntry_DoNotUse::MergeFrom(const Handle_MappingChannelsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata Handle_MappingChannelsEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[13]);
}

// ===================================================================

class Handle::_Internal {
 public:
  static const ::asf::msgbus::blackbox2::protocol::Instance& owner_node(const Handle* msg);
  static const ::asf::msgbus::blackbox2::protocol::Thread& owner_thread(const Handle* msg);
};

const ::asf::msgbus::blackbox2::protocol::Instance&
Handle::_Internal::owner_node(const Handle* msg) {
  return *msg->owner_node_;
}
const ::asf::msgbus::blackbox2::protocol::Thread&
Handle::_Internal::owner_thread(const Handle* msg) {
  return *msg->owner_thread_;
}
Handle::Handle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  mapping_channels_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.Handle)
}
Handle::Handle(const Handle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  mapping_channels_.MergeFrom(from.mapping_channels_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_owner_node()) {
    owner_node_ = new ::asf::msgbus::blackbox2::protocol::Instance(*from.owner_node_);
  } else {
    owner_node_ = nullptr;
  }
  if (from._internal_has_owner_thread()) {
    owner_thread_ = new ::asf::msgbus::blackbox2::protocol::Thread(*from.owner_thread_);
  } else {
    owner_thread_ = nullptr;
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_enabled_) -
    reinterpret_cast<char*>(&type_)) + sizeof(is_enabled_));
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.Handle)
}

inline void Handle::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&owner_node_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_enabled_) -
    reinterpret_cast<char*>(&owner_node_)) + sizeof(is_enabled_));
}

Handle::~Handle() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.Handle)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Handle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete owner_node_;
  if (this != internal_default_instance()) delete owner_thread_;
}

void Handle::ArenaDtor(void* object) {
  Handle* _this = reinterpret_cast< Handle* >(object);
  (void)_this;
  _this->mapping_channels_. ~MapField();
}
inline void Handle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &Handle::ArenaDtor);
  }
}
void Handle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Handle::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.Handle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mapping_channels_.Clear();
  key_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && owner_node_ != nullptr) {
    delete owner_node_;
  }
  owner_node_ = nullptr;
  if (GetArenaForAllocation() == nullptr && owner_thread_ != nullptr) {
    delete owner_thread_;
  }
  owner_thread_ = nullptr;
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_enabled_) -
      reinterpret_cast<char*>(&type_)) + sizeof(is_enabled_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Handle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .asf.msgbus.blackbox2.protocol.Instance owner_node = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_thread(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .asf.msgbus.blackbox2.protocol.HandleType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::asf::msgbus::blackbox2::protocol::HandleType>(val));
        } else
          goto handle_unusual;
        continue;
      // string key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Handle.key"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_enabled = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          is_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> mapping_channels = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&mapping_channels_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Handle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.Handle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .asf.msgbus.blackbox2.protocol.Instance owner_node = 1;
  if (this->_internal_has_owner_node()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::owner_node(this), target, stream);
  }

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  if (this->_internal_has_owner_thread()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::owner_thread(this), target, stream);
  }

  // .asf.msgbus.blackbox2.protocol.HandleType type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // string key = 4;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Handle.key");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_key(), target);
  }

  // bool is_enabled = 5;
  if (this->_internal_is_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_enabled(), target);
  }

  // map<string, string> mapping_channels = 6;
  if (!this->_internal_mapping_channels().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "asf.msgbus.blackbox2.protocol.Handle.MappingChannelsEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "asf.msgbus.blackbox2.protocol.Handle.MappingChannelsEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_mapping_channels().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_mapping_channels().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_mapping_channels().begin();
          it != this->_internal_mapping_channels().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = Handle_MappingChannelsEntry_DoNotUse::Funcs::InternalSerialize(6, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_mapping_channels().begin();
          it != this->_internal_mapping_channels().end(); ++it) {
        target = Handle_MappingChannelsEntry_DoNotUse::Funcs::InternalSerialize(6, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.Handle)
  return target;
}

size_t Handle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.Handle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> mapping_channels = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_mapping_channels_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_mapping_channels().begin();
      it != this->_internal_mapping_channels().end(); ++it) {
    total_size += Handle_MappingChannelsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string key = 4;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // .asf.msgbus.blackbox2.protocol.Instance owner_node = 1;
  if (this->_internal_has_owner_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_node_);
  }

  // .asf.msgbus.blackbox2.protocol.Thread owner_thread = 2;
  if (this->_internal_has_owner_thread()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_thread_);
  }

  // .asf.msgbus.blackbox2.protocol.HandleType type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  // bool is_enabled = 5;
  if (this->_internal_is_enabled() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Handle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Handle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Handle::GetClassData() const { return &_class_data_; }

void Handle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Handle *>(to)->MergeFrom(
      static_cast<const Handle &>(from));
}


void Handle::MergeFrom(const Handle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.Handle)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  mapping_channels_.MergeFrom(from.mapping_channels_);
  if (!from._internal_key().empty()) {
    _internal_set_key(from._internal_key());
  }
  if (from._internal_has_owner_node()) {
    _internal_mutable_owner_node()->::asf::msgbus::blackbox2::protocol::Instance::MergeFrom(from._internal_owner_node());
  }
  if (from._internal_has_owner_thread()) {
    _internal_mutable_owner_thread()->::asf::msgbus::blackbox2::protocol::Thread::MergeFrom(from._internal_owner_thread());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  if (from._internal_is_enabled() != 0) {
    _internal_set_is_enabled(from._internal_is_enabled());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Handle::CopyFrom(const Handle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.Handle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Handle::IsInitialized() const {
  return true;
}

void Handle::InternalSwap(Handle* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  mapping_channels_.InternalSwap(&other->mapping_channels_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Handle, is_enabled_)
      + sizeof(Handle::is_enabled_)
      - PROTOBUF_FIELD_OFFSET(Handle, owner_node_)>(
          reinterpret_cast<char*>(&owner_node_),
          reinterpret_cast<char*>(&other->owner_node_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Handle::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[14]);
}

// ===================================================================

class AttachResponse::_Internal {
 public:
  static const ::asf::msgbus::blackbox2::protocol::Instance& instance(const AttachResponse* msg);
};

const ::asf::msgbus::blackbox2::protocol::Instance&
AttachResponse::_Internal::instance(const AttachResponse* msg) {
  return *msg->instance_;
}
AttachResponse::AttachResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.AttachResponse)
}
AttachResponse::AttachResponse(const AttachResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_instance()) {
    instance_ = new ::asf::msgbus::blackbox2::protocol::Instance(*from.instance_);
  } else {
    instance_ = nullptr;
  }
  is_activated_ = from.is_activated_;
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.AttachResponse)
}

inline void AttachResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&instance_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_activated_) -
    reinterpret_cast<char*>(&instance_)) + sizeof(is_activated_));
}

AttachResponse::~AttachResponse() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.AttachResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AttachResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete instance_;
}

void AttachResponse::ArenaDtor(void* object) {
  AttachResponse* _this = reinterpret_cast< AttachResponse* >(object);
  (void)_this;
}
void AttachResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AttachResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AttachResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.AttachResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && instance_ != nullptr) {
    delete instance_;
  }
  instance_ = nullptr;
  is_activated_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AttachResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .asf.msgbus.blackbox2.protocol.Instance instance = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_instance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_activated = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          is_activated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AttachResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.AttachResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .asf.msgbus.blackbox2.protocol.Instance instance = 1;
  if (this->_internal_has_instance()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::instance(this), target, stream);
  }

  // bool is_activated = 2;
  if (this->_internal_is_activated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_activated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.AttachResponse)
  return target;
}

size_t AttachResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.AttachResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .asf.msgbus.blackbox2.protocol.Instance instance = 1;
  if (this->_internal_has_instance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *instance_);
  }

  // bool is_activated = 2;
  if (this->_internal_is_activated() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AttachResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AttachResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AttachResponse::GetClassData() const { return &_class_data_; }

void AttachResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AttachResponse *>(to)->MergeFrom(
      static_cast<const AttachResponse &>(from));
}


void AttachResponse::MergeFrom(const AttachResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.AttachResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_instance()) {
    _internal_mutable_instance()->::asf::msgbus::blackbox2::protocol::Instance::MergeFrom(from._internal_instance());
  }
  if (from._internal_is_activated() != 0) {
    _internal_set_is_activated(from._internal_is_activated());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AttachResponse::CopyFrom(const AttachResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.AttachResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttachResponse::IsInitialized() const {
  return true;
}

void AttachResponse::InternalSwap(AttachResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AttachResponse, is_activated_)
      + sizeof(AttachResponse::is_activated_)
      - PROTOBUF_FIELD_OFFSET(AttachResponse, instance_)>(
          reinterpret_cast<char*>(&instance_),
          reinterpret_cast<char*>(&other->instance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AttachResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[15]);
}

// ===================================================================

class Message::_Internal {
 public:
  using HasBits = decltype(std::declval<Message>()._has_bits_);
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_pod(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_serialize_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gen_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tx_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_rx_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_write_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_read_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Message::Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.Message)
}
Message::Message(const Message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  payload_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload()) {
    payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_payload(), 
      GetArenaForAllocation());
  }
  serialize_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serialize_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialize_type()) {
    serialize_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serialize_type(), 
      GetArenaForAllocation());
  }
  ::memcpy(&dir_, &from.dir_,
    static_cast<size_t>(reinterpret_cast<char*>(&read_timestamp_) -
    reinterpret_cast<char*>(&dir_)) + sizeof(read_timestamp_));
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.Message)
}

inline void Message::SharedCtor() {
payload_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
serialize_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serialize_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dir_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&read_timestamp_) -
    reinterpret_cast<char*>(&dir_)) + sizeof(read_timestamp_));
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.Message)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  payload_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serialize_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Message::ArenaDtor(void* object) {
  Message* _this = reinterpret_cast< Message* >(object);
  (void)_this;
}
void Message::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Message::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.Message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      serialize_type_.ClearNonDefaultToEmpty();
    }
  }
  dir_ = 0;
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&is_pod_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&read_timestamp_) -
        reinterpret_cast<char*>(&is_pod_)) + sizeof(read_timestamp_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Message::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .asf.msgbus.blackbox2.protocol.Direction dir = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dir(static_cast<::asf::msgbus::blackbox2::protocol::Direction>(val));
        } else
          goto handle_unusual;
        continue;
      // optional bytes payload = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_payload();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_pod = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_pod(&has_bits);
          is_pod_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string serialize_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_serialize_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "asf.msgbus.blackbox2.protocol.Message.serialize_type"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 gen_timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gen_timestamp(&has_bits);
          gen_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tx_timestamp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_tx_timestamp(&has_bits);
          tx_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 rx_timestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_rx_timestamp(&has_bits);
          rx_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 write_timestamp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_write_timestamp(&has_bits);
          write_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 read_timestamp = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_read_timestamp(&has_bits);
          read_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.Message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .asf.msgbus.blackbox2.protocol.Direction dir = 1;
  if (this->_internal_dir() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_dir(), target);
  }

  // optional bytes payload = 2;
  if (_internal_has_payload()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_payload(), target);
  }

  // optional bool is_pod = 3;
  if (_internal_has_is_pod()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_pod(), target);
  }

  // optional string serialize_type = 4;
  if (_internal_has_serialize_type()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_serialize_type().data(), static_cast<int>(this->_internal_serialize_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "asf.msgbus.blackbox2.protocol.Message.serialize_type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_serialize_type(), target);
  }

  // optional uint64 gen_timestamp = 5;
  if (_internal_has_gen_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_gen_timestamp(), target);
  }

  // optional uint64 tx_timestamp = 6;
  if (_internal_has_tx_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_tx_timestamp(), target);
  }

  // optional uint64 rx_timestamp = 7;
  if (_internal_has_rx_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_rx_timestamp(), target);
  }

  // optional uint64 write_timestamp = 8;
  if (_internal_has_write_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_write_timestamp(), target);
  }

  // optional uint64 read_timestamp = 9;
  if (_internal_has_read_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_read_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.Message)
  return target;
}

size_t Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.Message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes payload = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload());
    }

    // optional string serialize_type = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_serialize_type());
    }

  }
  // .asf.msgbus.blackbox2.protocol.Direction dir = 1;
  if (this->_internal_dir() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_dir());
  }

  if (cached_has_bits & 0x000000fcu) {
    // optional bool is_pod = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint64 gen_timestamp = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_gen_timestamp());
    }

    // optional uint64 tx_timestamp = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_tx_timestamp());
    }

    // optional uint64 rx_timestamp = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_rx_timestamp());
    }

    // optional uint64 write_timestamp = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_write_timestamp());
    }

    // optional uint64 read_timestamp = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_read_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Message::GetClassData() const { return &_class_data_; }

void Message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Message *>(to)->MergeFrom(
      static_cast<const Message &>(from));
}


void Message::MergeFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.Message)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_payload(from._internal_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_serialize_type(from._internal_serialize_type());
    }
  }
  if (from._internal_dir() != 0) {
    _internal_set_dir(from._internal_dir());
  }
  if (cached_has_bits & 0x000000fcu) {
    if (cached_has_bits & 0x00000004u) {
      is_pod_ = from.is_pod_;
    }
    if (cached_has_bits & 0x00000008u) {
      gen_timestamp_ = from.gen_timestamp_;
    }
    if (cached_has_bits & 0x00000010u) {
      tx_timestamp_ = from.tx_timestamp_;
    }
    if (cached_has_bits & 0x00000020u) {
      rx_timestamp_ = from.rx_timestamp_;
    }
    if (cached_has_bits & 0x00000040u) {
      write_timestamp_ = from.write_timestamp_;
    }
    if (cached_has_bits & 0x00000080u) {
      read_timestamp_ = from.read_timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  return true;
}

void Message::InternalSwap(Message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &payload_, lhs_arena,
      &other->payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serialize_type_, lhs_arena,
      &other->serialize_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Message, read_timestamp_)
      + sizeof(Message::read_timestamp_)
      - PROTOBUF_FIELD_OFFSET(Message, dir_)>(
          reinterpret_cast<char*>(&dir_),
          reinterpret_cast<char*>(&other->dir_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Message::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[16]);
}

// ===================================================================

class MessageFields::_Internal {
 public:
};

MessageFields::MessageFields(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:asf.msgbus.blackbox2.protocol.MessageFields)
}
MessageFields::MessageFields(const MessageFields& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  has_flags_ = from.has_flags_;
  // @@protoc_insertion_point(copy_constructor:asf.msgbus.blackbox2.protocol.MessageFields)
}

inline void MessageFields::SharedCtor() {
has_flags_ = 0u;
}

MessageFields::~MessageFields() {
  // @@protoc_insertion_point(destructor:asf.msgbus.blackbox2.protocol.MessageFields)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MessageFields::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MessageFields::ArenaDtor(void* object) {
  MessageFields* _this = reinterpret_cast< MessageFields* >(object);
  (void)_this;
}
void MessageFields::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MessageFields::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MessageFields::Clear() {
// @@protoc_insertion_point(message_clear_start:asf.msgbus.blackbox2.protocol.MessageFields)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  has_flags_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MessageFields::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 has_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          has_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MessageFields::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:asf.msgbus.blackbox2.protocol.MessageFields)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 has_flags = 1;
  if (this->_internal_has_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_has_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:asf.msgbus.blackbox2.protocol.MessageFields)
  return target;
}

size_t MessageFields::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:asf.msgbus.blackbox2.protocol.MessageFields)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 has_flags = 1;
  if (this->_internal_has_flags() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_has_flags());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MessageFields::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MessageFields::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MessageFields::GetClassData() const { return &_class_data_; }

void MessageFields::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MessageFields *>(to)->MergeFrom(
      static_cast<const MessageFields &>(from));
}


void MessageFields::MergeFrom(const MessageFields& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:asf.msgbus.blackbox2.protocol.MessageFields)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_flags() != 0) {
    _internal_set_has_flags(from._internal_has_flags());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MessageFields::CopyFrom(const MessageFields& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:asf.msgbus.blackbox2.protocol.MessageFields)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageFields::IsInitialized() const {
  return true;
}

void MessageFields::InternalSwap(MessageFields* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(has_flags_, other->has_flags_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MessageFields::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protocol_5fmessage_2eproto_getter, &descriptor_table_protocol_5fmessage_2eproto_once,
      file_level_metadata_protocol_5fmessage_2eproto[17]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace protocol
}  // namespace blackbox2
}  // namespace msgbus
}  // namespace asf
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Boolean* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Boolean >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Boolean >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::String* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::String >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::String >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Instance* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Instance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Instance >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Result* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Result >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Version* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Version >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Version >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Thread* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Thread >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Thread >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Process* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Process >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Process >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Channel_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Channel_ConfigEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Channel_ConfigEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Channel* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Channel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Channel >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Executor* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Executor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Executor >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::ExecutorTask* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::ExecutorTask >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::ExecutorTask >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Node* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Node >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::KeyStat* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::KeyStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::KeyStat >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Handle_MappingChannelsEntry_DoNotUse* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Handle_MappingChannelsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Handle_MappingChannelsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Handle* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Handle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Handle >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::AttachResponse* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::AttachResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::AttachResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::Message* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::Message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::Message >(arena);
}
template<> PROTOBUF_NOINLINE ::asf::msgbus::blackbox2::protocol::MessageFields* Arena::CreateMaybeMessage< ::asf::msgbus::blackbox2::protocol::MessageFields >(Arena* arena) {
  return Arena::CreateMessageInternal< ::asf::msgbus::blackbox2::protocol::MessageFields >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
